// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SimulationInputSchema.hxx"

// celestial_body
//

const celestial_body::coordinate_type& celestial_body::
coordinate () const
{
  return this->coordinate_.get ();
}

celestial_body::coordinate_type& celestial_body::
coordinate ()
{
  return this->coordinate_.get ();
}

void celestial_body::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void celestial_body::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const celestial_body::velocity_type& celestial_body::
velocity () const
{
  return this->velocity_.get ();
}

celestial_body::velocity_type& celestial_body::
velocity ()
{
  return this->velocity_.get ();
}

void celestial_body::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void celestial_body::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const celestial_body::mass_type& celestial_body::
mass () const
{
  return this->mass_.get ();
}

celestial_body::mass_type& celestial_body::
mass ()
{
  return this->mass_.get ();
}

void celestial_body::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void celestial_body::
mass (::std::unique_ptr< mass_type > x)
{
  this->mass_.set (std::move (x));
}


// cuboid
//

const cuboid::coordinate_type& cuboid::
coordinate () const
{
  return this->coordinate_.get ();
}

cuboid::coordinate_type& cuboid::
coordinate ()
{
  return this->coordinate_.get ();
}

void cuboid::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void cuboid::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const cuboid::dimensions_type& cuboid::
dimensions () const
{
  return this->dimensions_.get ();
}

cuboid::dimensions_type& cuboid::
dimensions ()
{
  return this->dimensions_.get ();
}

void cuboid::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

void cuboid::
dimensions (::std::unique_ptr< dimensions_type > x)
{
  this->dimensions_.set (std::move (x));
}

const cuboid::velocity_type& cuboid::
velocity () const
{
  return this->velocity_.get ();
}

cuboid::velocity_type& cuboid::
velocity ()
{
  return this->velocity_.get ();
}

void cuboid::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboid::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const cuboid::particleTypeId_type& cuboid::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

cuboid::particleTypeId_type& cuboid::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void cuboid::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}

const cuboid::spacing_optional& cuboid::
spacing () const
{
  return this->spacing_;
}

cuboid::spacing_optional& cuboid::
spacing ()
{
  return this->spacing_;
}

void cuboid::
spacing (const spacing_type& x)
{
  this->spacing_.set (x);
}

void cuboid::
spacing (const spacing_optional& x)
{
  this->spacing_ = x;
}

const cuboid::fixed_optional& cuboid::
fixed () const
{
  return this->fixed_;
}

cuboid::fixed_optional& cuboid::
fixed ()
{
  return this->fixed_;
}

void cuboid::
fixed (const fixed_type& x)
{
  this->fixed_.set (x);
}

void cuboid::
fixed (const fixed_optional& x)
{
  this->fixed_ = x;
}


// disc
//

const disc::coordinate_type& disc::
coordinate () const
{
  return this->coordinate_.get ();
}

disc::coordinate_type& disc::
coordinate ()
{
  return this->coordinate_.get ();
}

void disc::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void disc::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const disc::velocity_type& disc::
velocity () const
{
  return this->velocity_.get ();
}

disc::velocity_type& disc::
velocity ()
{
  return this->velocity_.get ();
}

void disc::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void disc::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const disc::radius_type& disc::
radius () const
{
  return this->radius_.get ();
}

disc::radius_type& disc::
radius ()
{
  return this->radius_.get ();
}

void disc::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void disc::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}

const disc::particleTypeId_type& disc::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

disc::particleTypeId_type& disc::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void disc::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}


// sphere
//

const sphere::coordinate_type& sphere::
coordinate () const
{
  return this->coordinate_.get ();
}

sphere::coordinate_type& sphere::
coordinate ()
{
  return this->coordinate_.get ();
}

void sphere::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void sphere::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const sphere::velocity_type& sphere::
velocity () const
{
  return this->velocity_.get ();
}

sphere::velocity_type& sphere::
velocity ()
{
  return this->velocity_.get ();
}

void sphere::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void sphere::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const sphere::radius_type& sphere::
radius () const
{
  return this->radius_.get ();
}

sphere::radius_type& sphere::
radius ()
{
  return this->radius_.get ();
}

void sphere::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void sphere::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}

const sphere::mesh_width_type& sphere::
mesh_width () const
{
  return this->mesh_width_.get ();
}

sphere::mesh_width_type& sphere::
mesh_width ()
{
  return this->mesh_width_.get ();
}

void sphere::
mesh_width (const mesh_width_type& x)
{
  this->mesh_width_.set (x);
}

const sphere::particleTypeId_type& sphere::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

sphere::particleTypeId_type& sphere::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void sphere::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}


// torus
//

const torus::coordinate_type& torus::
coordinate () const
{
  return this->coordinate_.get ();
}

torus::coordinate_type& torus::
coordinate ()
{
  return this->coordinate_.get ();
}

void torus::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void torus::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const torus::velocity_type& torus::
velocity () const
{
  return this->velocity_.get ();
}

torus::velocity_type& torus::
velocity ()
{
  return this->velocity_.get ();
}

void torus::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void torus::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const torus::major_radius_type& torus::
major_radius () const
{
  return this->major_radius_.get ();
}

torus::major_radius_type& torus::
major_radius ()
{
  return this->major_radius_.get ();
}

void torus::
major_radius (const major_radius_type& x)
{
  this->major_radius_.set (x);
}

void torus::
major_radius (::std::unique_ptr< major_radius_type > x)
{
  this->major_radius_.set (std::move (x));
}

const torus::minor_radius_type& torus::
minor_radius () const
{
  return this->minor_radius_.get ();
}

torus::minor_radius_type& torus::
minor_radius ()
{
  return this->minor_radius_.get ();
}

void torus::
minor_radius (const minor_radius_type& x)
{
  this->minor_radius_.set (x);
}

void torus::
minor_radius (::std::unique_ptr< minor_radius_type > x)
{
  this->minor_radius_.set (std::move (x));
}

const torus::particleTypeId_type& torus::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

torus::particleTypeId_type& torus::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void torus::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}


// double_helix
//

const double_helix::coordinate_type& double_helix::
coordinate () const
{
  return this->coordinate_.get ();
}

double_helix::coordinate_type& double_helix::
coordinate ()
{
  return this->coordinate_.get ();
}

void double_helix::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void double_helix::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const double_helix::velocity_type& double_helix::
velocity () const
{
  return this->velocity_.get ();
}

double_helix::velocity_type& double_helix::
velocity ()
{
  return this->velocity_.get ();
}

void double_helix::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void double_helix::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const double_helix::radius_type& double_helix::
radius () const
{
  return this->radius_.get ();
}

double_helix::radius_type& double_helix::
radius ()
{
  return this->radius_.get ();
}

void double_helix::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void double_helix::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}

const double_helix::pitch_type& double_helix::
pitch () const
{
  return this->pitch_.get ();
}

double_helix::pitch_type& double_helix::
pitch ()
{
  return this->pitch_.get ();
}

void double_helix::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void double_helix::
pitch (::std::unique_ptr< pitch_type > x)
{
  this->pitch_.set (std::move (x));
}

const double_helix::height_type& double_helix::
height () const
{
  return this->height_.get ();
}

double_helix::height_type& double_helix::
height ()
{
  return this->height_.get ();
}

void double_helix::
height (const height_type& x)
{
  this->height_.set (x);
}

void double_helix::
height (::std::unique_ptr< height_type > x)
{
  this->height_.set (std::move (x));
}

const double_helix::particleTypeId_type& double_helix::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

double_helix::particleTypeId_type& double_helix::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void double_helix::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}


// coordinate
//

const coordinate::x_type& coordinate::
x () const
{
  return this->x_.get ();
}

coordinate::x_type& coordinate::
x ()
{
  return this->x_.get ();
}

void coordinate::
x (const x_type& x)
{
  this->x_.set (x);
}

const coordinate::y_type& coordinate::
y () const
{
  return this->y_.get ();
}

coordinate::y_type& coordinate::
y ()
{
  return this->y_.get ();
}

void coordinate::
y (const y_type& x)
{
  this->y_.set (x);
}

const coordinate::z_optional& coordinate::
z () const
{
  return this->z_;
}

coordinate::z_optional& coordinate::
z ()
{
  return this->z_;
}

void coordinate::
z (const z_type& x)
{
  this->z_.set (x);
}

void coordinate::
z (const z_optional& x)
{
  this->z_ = x;
}


// velocity
//

const velocity::x_type& velocity::
x () const
{
  return this->x_.get ();
}

velocity::x_type& velocity::
x ()
{
  return this->x_.get ();
}

void velocity::
x (const x_type& x)
{
  this->x_.set (x);
}

const velocity::y_type& velocity::
y () const
{
  return this->y_.get ();
}

velocity::y_type& velocity::
y ()
{
  return this->y_.get ();
}

void velocity::
y (const y_type& x)
{
  this->y_.set (x);
}

const velocity::z_optional& velocity::
z () const
{
  return this->z_;
}

velocity::z_optional& velocity::
z ()
{
  return this->z_;
}

void velocity::
z (const z_type& x)
{
  this->z_.set (x);
}

void velocity::
z (const z_optional& x)
{
  this->z_ = x;
}


// dimensions
//

const dimensions::x_type& dimensions::
x () const
{
  return this->x_.get ();
}

dimensions::x_type& dimensions::
x ()
{
  return this->x_.get ();
}

void dimensions::
x (const x_type& x)
{
  this->x_.set (x);
}

const dimensions::y_type& dimensions::
y () const
{
  return this->y_.get ();
}

dimensions::y_type& dimensions::
y ()
{
  return this->y_.get ();
}

void dimensions::
y (const y_type& x)
{
  this->y_.set (x);
}

const dimensions::z_optional& dimensions::
z () const
{
  return this->z_;
}

dimensions::z_optional& dimensions::
z ()
{
  return this->z_;
}

void dimensions::
z (const z_type& x)
{
  this->z_.set (x);
}

void dimensions::
z (const z_optional& x)
{
  this->z_ = x;
}


// positive_int
//


// positive_double
//


// scenario
//

const scenario::header_type& scenario::
header () const
{
  return this->header_.get ();
}

scenario::header_type& scenario::
header ()
{
  return this->header_.get ();
}

void scenario::
header (const header_type& x)
{
  this->header_.set (x);
}

void scenario::
header (::std::unique_ptr< header_type > x)
{
  this->header_.set (std::move (x));
}

const scenario::checkpoints_optional& scenario::
checkpoints () const
{
  return this->checkpoints_;
}

scenario::checkpoints_optional& scenario::
checkpoints ()
{
  return this->checkpoints_;
}

void scenario::
checkpoints (const checkpoints_type& x)
{
  this->checkpoints_.set (x);
}

void scenario::
checkpoints (const checkpoints_optional& x)
{
  this->checkpoints_ = x;
}

void scenario::
checkpoints (::std::unique_ptr< checkpoints_type > x)
{
  this->checkpoints_.set (std::move (x));
}

const scenario::thermostat_optional& scenario::
thermostat () const
{
  return this->thermostat_;
}

scenario::thermostat_optional& scenario::
thermostat ()
{
  return this->thermostat_;
}

void scenario::
thermostat (const thermostat_type& x)
{
  this->thermostat_.set (x);
}

void scenario::
thermostat (const thermostat_optional& x)
{
  this->thermostat_ = x;
}

void scenario::
thermostat (::std::unique_ptr< thermostat_type > x)
{
  this->thermostat_.set (std::move (x));
}

const scenario::nanotube_optional& scenario::
nanotube () const
{
  return this->nanotube_;
}

scenario::nanotube_optional& scenario::
nanotube ()
{
  return this->nanotube_;
}

void scenario::
nanotube (const nanotube_type& x)
{
  this->nanotube_.set (x);
}

void scenario::
nanotube (const nanotube_optional& x)
{
  this->nanotube_ = x;
}

void scenario::
nanotube (::std::unique_ptr< nanotube_type > x)
{
  this->nanotube_.set (std::move (x));
}

const scenario::container_type& scenario::
container () const
{
  return this->container_.get ();
}

scenario::container_type& scenario::
container ()
{
  return this->container_.get ();
}

void scenario::
container (const container_type& x)
{
  this->container_.set (x);
}

void scenario::
container (::std::unique_ptr< container_type > x)
{
  this->container_.set (std::move (x));
}

const scenario::forces_type& scenario::
forces () const
{
  return this->forces_.get ();
}

scenario::forces_type& scenario::
forces ()
{
  return this->forces_.get ();
}

void scenario::
forces (const forces_type& x)
{
  this->forces_.set (x);
}

void scenario::
forces (::std::unique_ptr< forces_type > x)
{
  this->forces_.set (std::move (x));
}


// header
//

const header::base_name_type& header::
base_name () const
{
  return this->base_name_.get ();
}

header::base_name_type& header::
base_name ()
{
  return this->base_name_.get ();
}

void header::
base_name (const base_name_type& x)
{
  this->base_name_.set (x);
}

void header::
base_name (::std::unique_ptr< base_name_type > x)
{
  this->base_name_.set (std::move (x));
}

const header::t_start_optional& header::
t_start () const
{
  return this->t_start_;
}

header::t_start_optional& header::
t_start ()
{
  return this->t_start_;
}

void header::
t_start (const t_start_type& x)
{
  this->t_start_.set (x);
}

void header::
t_start (const t_start_optional& x)
{
  this->t_start_ = x;
}

void header::
t_start (::std::unique_ptr< t_start_type > x)
{
  this->t_start_.set (std::move (x));
}

const header::t_end_type& header::
t_end () const
{
  return this->t_end_.get ();
}

header::t_end_type& header::
t_end ()
{
  return this->t_end_.get ();
}

void header::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

void header::
t_end (::std::unique_ptr< t_end_type > x)
{
  this->t_end_.set (std::move (x));
}

const header::delta_t_type& header::
delta_t () const
{
  return this->delta_t_.get ();
}

header::delta_t_type& header::
delta_t ()
{
  return this->delta_t_.get ();
}

void header::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const header::output_frequency_type& header::
output_frequency () const
{
  return this->output_frequency_.get ();
}

header::output_frequency_type& header::
output_frequency ()
{
  return this->output_frequency_.get ();
}

void header::
output_frequency (const output_frequency_type& x)
{
  this->output_frequency_.set (x);
}

void header::
output_frequency (::std::unique_ptr< output_frequency_type > x)
{
  this->output_frequency_.set (std::move (x));
}

const header::output_file_type& header::
output_file () const
{
  return this->output_file_.get ();
}

header::output_file_type& header::
output_file ()
{
  return this->output_file_.get ();
}

void header::
output_file (const output_file_type& x)
{
  this->output_file_.set (x);
}

void header::
output_file (::std::unique_ptr< output_file_type > x)
{
  this->output_file_.set (std::move (x));
}

const header::seed_type& header::
seed () const
{
  return this->seed_.get ();
}

header::seed_type& header::
seed ()
{
  return this->seed_.get ();
}

void header::
seed (const seed_type& x)
{
  this->seed_.set (x);
}

const header::dimensions_type& header::
dimensions () const
{
  return this->dimensions_.get ();
}

header::dimensions_type& header::
dimensions ()
{
  return this->dimensions_.get ();
}

void header::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

const header::parallelized_type& header::
parallelized () const
{
  return this->parallelized_.get ();
}

header::parallelized_type& header::
parallelized ()
{
  return this->parallelized_.get ();
}

void header::
parallelized (const parallelized_type& x)
{
  this->parallelized_.set (x);
}

const header::vectorized_type& header::
vectorized () const
{
  return this->vectorized_.get ();
}

header::vectorized_type& header::
vectorized ()
{
  return this->vectorized_.get ();
}

void header::
vectorized (const vectorized_type& x)
{
  this->vectorized_.set (x);
}


// checkpoints
//

const checkpoints::checkpoint_sequence& checkpoints::
checkpoint () const
{
  return this->checkpoint_;
}

checkpoints::checkpoint_sequence& checkpoints::
checkpoint ()
{
  return this->checkpoint_;
}

void checkpoints::
checkpoint (const checkpoint_sequence& s)
{
  this->checkpoint_ = s;
}

const checkpoints::path_optional& checkpoints::
path () const
{
  return this->path_;
}

checkpoints::path_optional& checkpoints::
path ()
{
  return this->path_;
}

void checkpoints::
path (const path_type& x)
{
  this->path_.set (x);
}

void checkpoints::
path (const path_optional& x)
{
  this->path_ = x;
}

void checkpoints::
path (::std::unique_ptr< path_type > x)
{
  this->path_.set (std::move (x));
}


// thermostat
//

const thermostat::t_init_type& thermostat::
t_init () const
{
  return this->t_init_.get ();
}

thermostat::t_init_type& thermostat::
t_init ()
{
  return this->t_init_.get ();
}

void thermostat::
t_init (const t_init_type& x)
{
  this->t_init_.set (x);
}

const thermostat::t_target_optional& thermostat::
t_target () const
{
  return this->t_target_;
}

thermostat::t_target_optional& thermostat::
t_target ()
{
  return this->t_target_;
}

void thermostat::
t_target (const t_target_type& x)
{
  this->t_target_.set (x);
}

void thermostat::
t_target (const t_target_optional& x)
{
  this->t_target_ = x;
}

const thermostat::frequency_type& thermostat::
frequency () const
{
  return this->frequency_.get ();
}

thermostat::frequency_type& thermostat::
frequency ()
{
  return this->frequency_.get ();
}

void thermostat::
frequency (const frequency_type& x)
{
  this->frequency_.set (x);
}

const thermostat::max_temp_diff_optional& thermostat::
max_temp_diff () const
{
  return this->max_temp_diff_;
}

thermostat::max_temp_diff_optional& thermostat::
max_temp_diff ()
{
  return this->max_temp_diff_;
}

void thermostat::
max_temp_diff (const max_temp_diff_type& x)
{
  this->max_temp_diff_.set (x);
}

void thermostat::
max_temp_diff (const max_temp_diff_optional& x)
{
  this->max_temp_diff_ = x;
}

const thermostat::brownian_motion_optional& thermostat::
brownian_motion () const
{
  return this->brownian_motion_;
}

thermostat::brownian_motion_optional& thermostat::
brownian_motion ()
{
  return this->brownian_motion_;
}

void thermostat::
brownian_motion (const brownian_motion_type& x)
{
  this->brownian_motion_.set (x);
}

void thermostat::
brownian_motion (const brownian_motion_optional& x)
{
  this->brownian_motion_ = x;
}


// nanotube
//

const nanotube::n_bins_type& nanotube::
n_bins () const
{
  return this->n_bins_.get ();
}

nanotube::n_bins_type& nanotube::
n_bins ()
{
  return this->n_bins_.get ();
}

void nanotube::
n_bins (const n_bins_type& x)
{
  this->n_bins_.set (x);
}

void nanotube::
n_bins (::std::unique_ptr< n_bins_type > x)
{
  this->n_bins_.set (std::move (x));
}

const nanotube::iterations_type& nanotube::
iterations () const
{
  return this->iterations_.get ();
}

nanotube::iterations_type& nanotube::
iterations ()
{
  return this->iterations_.get ();
}

void nanotube::
iterations (const iterations_type& x)
{
  this->iterations_.set (x);
}

void nanotube::
iterations (::std::unique_ptr< iterations_type > x)
{
  this->iterations_.set (std::move (x));
}


// container
//

const container::linked_cells_optional& container::
linked_cells () const
{
  return this->linked_cells_;
}

container::linked_cells_optional& container::
linked_cells ()
{
  return this->linked_cells_;
}

void container::
linked_cells (const linked_cells_type& x)
{
  this->linked_cells_.set (x);
}

void container::
linked_cells (const linked_cells_optional& x)
{
  this->linked_cells_ = x;
}

void container::
linked_cells (::std::unique_ptr< linked_cells_type > x)
{
  this->linked_cells_.set (std::move (x));
}

const container::vector_optional& container::
vector () const
{
  return this->vector_;
}

container::vector_optional& container::
vector ()
{
  return this->vector_;
}

void container::
vector (const vector_type& x)
{
  this->vector_.set (x);
}

void container::
vector (const vector_optional& x)
{
  this->vector_ = x;
}

void container::
vector (::std::unique_ptr< vector_type > x)
{
  this->vector_.set (std::move (x));
}

const container::vector_type& container::
vector_default_value ()
{
  return vector_default_value_;
}


// forces
//

const forces::gravity_optional& forces::
gravity () const
{
  return this->gravity_;
}

forces::gravity_optional& forces::
gravity ()
{
  return this->gravity_;
}

void forces::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void forces::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

const forces::lennard_jones_optional& forces::
lennard_jones () const
{
  return this->lennard_jones_;
}

forces::lennard_jones_optional& forces::
lennard_jones ()
{
  return this->lennard_jones_;
}

void forces::
lennard_jones (const lennard_jones_type& x)
{
  this->lennard_jones_.set (x);
}

void forces::
lennard_jones (const lennard_jones_optional& x)
{
  this->lennard_jones_ = x;
}

void forces::
lennard_jones (::std::unique_ptr< lennard_jones_type > x)
{
  this->lennard_jones_.set (std::move (x));
}


// linked_cells
//

const linked_cells::domain_size_type& linked_cells::
domain_size () const
{
  return this->domain_size_.get ();
}

linked_cells::domain_size_type& linked_cells::
domain_size ()
{
  return this->domain_size_.get ();
}

void linked_cells::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void linked_cells::
domain_size (::std::unique_ptr< domain_size_type > x)
{
  this->domain_size_.set (std::move (x));
}

const linked_cells::boundary_conditions_type& linked_cells::
boundary_conditions () const
{
  return this->boundary_conditions_.get ();
}

linked_cells::boundary_conditions_type& linked_cells::
boundary_conditions ()
{
  return this->boundary_conditions_.get ();
}

void linked_cells::
boundary_conditions (const boundary_conditions_type& x)
{
  this->boundary_conditions_.set (x);
}

void linked_cells::
boundary_conditions (::std::unique_ptr< boundary_conditions_type > x)
{
  this->boundary_conditions_.set (std::move (x));
}

const linked_cells::cutoff_radius_type& linked_cells::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

linked_cells::cutoff_radius_type& linked_cells::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void linked_cells::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

void linked_cells::
cutoff_radius (::std::unique_ptr< cutoff_radius_type > x)
{
  this->cutoff_radius_.set (std::move (x));
}


// lennard_jones
//

const lennard_jones::particleTypes_type& lennard_jones::
particleTypes () const
{
  return this->particleTypes_.get ();
}

lennard_jones::particleTypes_type& lennard_jones::
particleTypes ()
{
  return this->particleTypes_.get ();
}

void lennard_jones::
particleTypes (const particleTypes_type& x)
{
  this->particleTypes_.set (x);
}

void lennard_jones::
particleTypes (::std::unique_ptr< particleTypes_type > x)
{
  this->particleTypes_.set (std::move (x));
}

const lennard_jones::gravity_optional& lennard_jones::
gravity () const
{
  return this->gravity_;
}

lennard_jones::gravity_optional& lennard_jones::
gravity ()
{
  return this->gravity_;
}

void lennard_jones::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void lennard_jones::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

const lennard_jones::particles_optional& lennard_jones::
particles () const
{
  return this->particles_;
}

lennard_jones::particles_optional& lennard_jones::
particles ()
{
  return this->particles_;
}

void lennard_jones::
particles (const particles_type& x)
{
  this->particles_.set (x);
}

void lennard_jones::
particles (const particles_optional& x)
{
  this->particles_ = x;
}

void lennard_jones::
particles (::std::unique_ptr< particles_type > x)
{
  this->particles_.set (std::move (x));
}


// domain_size
//

const domain_size::x_type& domain_size::
x () const
{
  return this->x_.get ();
}

domain_size::x_type& domain_size::
x ()
{
  return this->x_.get ();
}

void domain_size::
x (const x_type& x)
{
  this->x_.set (x);
}

const domain_size::y_type& domain_size::
y () const
{
  return this->y_.get ();
}

domain_size::y_type& domain_size::
y ()
{
  return this->y_.get ();
}

void domain_size::
y (const y_type& x)
{
  this->y_.set (x);
}

const domain_size::z_optional& domain_size::
z () const
{
  return this->z_;
}

domain_size::z_optional& domain_size::
z ()
{
  return this->z_;
}

void domain_size::
z (const z_type& x)
{
  this->z_.set (x);
}

void domain_size::
z (const z_optional& x)
{
  this->z_ = x;
}


// boundary_conditions
//

const boundary_conditions::boundary_condition_sequence& boundary_conditions::
boundary_condition () const
{
  return this->boundary_condition_;
}

boundary_conditions::boundary_condition_sequence& boundary_conditions::
boundary_condition ()
{
  return this->boundary_condition_;
}

void boundary_conditions::
boundary_condition (const boundary_condition_sequence& s)
{
  this->boundary_condition_ = s;
}


// particleTypes
//

const particleTypes::particleType_sequence& particleTypes::
particleType () const
{
  return this->particleType_;
}

particleTypes::particleType_sequence& particleTypes::
particleType ()
{
  return this->particleType_;
}

void particleTypes::
particleType (const particleType_sequence& s)
{
  this->particleType_ = s;
}


// particles
//

const particles::cuboid_sequence& particles::
cuboid () const
{
  return this->cuboid_;
}

particles::cuboid_sequence& particles::
cuboid ()
{
  return this->cuboid_;
}

void particles::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}

const particles::disc_sequence& particles::
disc () const
{
  return this->disc_;
}

particles::disc_sequence& particles::
disc ()
{
  return this->disc_;
}

void particles::
disc (const disc_sequence& s)
{
  this->disc_ = s;
}

const particles::sphere_sequence& particles::
sphere () const
{
  return this->sphere_;
}

particles::sphere_sequence& particles::
sphere ()
{
  return this->sphere_;
}

void particles::
sphere (const sphere_sequence& s)
{
  this->sphere_ = s;
}

const particles::torus_sequence& particles::
torus () const
{
  return this->torus_;
}

particles::torus_sequence& particles::
torus ()
{
  return this->torus_;
}

void particles::
torus (const torus_sequence& s)
{
  this->torus_ = s;
}

const particles::doubleHelix_sequence& particles::
doubleHelix () const
{
  return this->doubleHelix_;
}

particles::doubleHelix_sequence& particles::
doubleHelix ()
{
  return this->doubleHelix_;
}

void particles::
doubleHelix (const doubleHelix_sequence& s)
{
  this->doubleHelix_ = s;
}


// boundary_condition
//

const boundary_condition::type_type& boundary_condition::
type () const
{
  return this->type_.get ();
}

boundary_condition::type_type& boundary_condition::
type ()
{
  return this->type_.get ();
}

void boundary_condition::
type (const type_type& x)
{
  this->type_.set (x);
}

void boundary_condition::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// particleType
//

const particleType::id_type& particleType::
id () const
{
  return this->id_.get ();
}

particleType::id_type& particleType::
id ()
{
  return this->id_.get ();
}

void particleType::
id (const id_type& x)
{
  this->id_.set (x);
}

const particleType::sigma_type& particleType::
sigma () const
{
  return this->sigma_.get ();
}

particleType::sigma_type& particleType::
sigma ()
{
  return this->sigma_.get ();
}

void particleType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const particleType::epsilon_type& particleType::
epsilon () const
{
  return this->epsilon_.get ();
}

particleType::epsilon_type& particleType::
epsilon ()
{
  return this->epsilon_.get ();
}

void particleType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const particleType::mass_type& particleType::
mass () const
{
  return this->mass_.get ();
}

particleType::mass_type& particleType::
mass ()
{
  return this->mass_.get ();
}

void particleType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// celestial_body
//

celestial_body::
celestial_body (const coordinate_type& coordinate,
                const velocity_type& velocity,
                const mass_type& mass)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  mass_ (mass, this)
{
}

celestial_body::
celestial_body (::std::unique_ptr< coordinate_type > coordinate,
                ::std::unique_ptr< velocity_type > velocity,
                const mass_type& mass)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  mass_ (mass, this)
{
}

celestial_body::
celestial_body (const celestial_body& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this)
{
}

celestial_body::
celestial_body (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void celestial_body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!mass_.present ())
      {
        this->mass_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

celestial_body* celestial_body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class celestial_body (*this, f, c);
}

celestial_body& celestial_body::
operator= (const celestial_body& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
  }

  return *this;
}

celestial_body::
~celestial_body ()
{
}

// cuboid
//

cuboid::
cuboid (const coordinate_type& coordinate,
        const dimensions_type& dimensions,
        const velocity_type& velocity,
        const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  dimensions_ (dimensions, this),
  velocity_ (velocity, this),
  particleTypeId_ (particleTypeId, this),
  spacing_ (this),
  fixed_ (this)
{
}

cuboid::
cuboid (::std::unique_ptr< coordinate_type > coordinate,
        ::std::unique_ptr< dimensions_type > dimensions,
        ::std::unique_ptr< velocity_type > velocity,
        const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  dimensions_ (std::move (dimensions), this),
  velocity_ (std::move (velocity), this),
  particleTypeId_ (particleTypeId, this),
  spacing_ (this),
  fixed_ (this)
{
}

cuboid::
cuboid (const cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  dimensions_ (x.dimensions_, f, this),
  velocity_ (x.velocity_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this),
  spacing_ (x.spacing_, f, this),
  fixed_ (x.fixed_, f, this)
{
}

cuboid::
cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  dimensions_ (this),
  velocity_ (this),
  particleTypeId_ (this),
  spacing_ (this),
  fixed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dimensions_type > r (
        dimensions_traits::create (i, f, this));

      if (!dimensions_.present ())
      {
        this->dimensions_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensions",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "spacing" && n.namespace_ ().empty ())
    {
      this->spacing_.set (spacing_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "fixed" && n.namespace_ ().empty ())
    {
      this->fixed_.set (fixed_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

cuboid* cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid (*this, f, c);
}

cuboid& cuboid::
operator= (const cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->dimensions_ = x.dimensions_;
    this->velocity_ = x.velocity_;
    this->particleTypeId_ = x.particleTypeId_;
    this->spacing_ = x.spacing_;
    this->fixed_ = x.fixed_;
  }

  return *this;
}

cuboid::
~cuboid ()
{
}

// disc
//

disc::
disc (const coordinate_type& coordinate,
      const velocity_type& velocity,
      const radius_type& radius,
      const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

disc::
disc (::std::unique_ptr< coordinate_type > coordinate,
      ::std::unique_ptr< velocity_type > velocity,
      const radius_type& radius,
      const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

disc::
disc (const disc& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this)
{
}

disc::
disc (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this),
  particleTypeId_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void disc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

disc* disc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class disc (*this, f, c);
}

disc& disc::
operator= (const disc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
    this->particleTypeId_ = x.particleTypeId_;
  }

  return *this;
}

disc::
~disc ()
{
}

// sphere
//

sphere::
sphere (const coordinate_type& coordinate,
        const velocity_type& velocity,
        const radius_type& radius,
        const mesh_width_type& mesh_width,
        const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this),
  mesh_width_ (mesh_width, this),
  particleTypeId_ (particleTypeId, this)
{
}

sphere::
sphere (::std::unique_ptr< coordinate_type > coordinate,
        ::std::unique_ptr< velocity_type > velocity,
        const radius_type& radius,
        const mesh_width_type& mesh_width,
        const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this),
  mesh_width_ (mesh_width, this),
  particleTypeId_ (particleTypeId, this)
{
}

sphere::
sphere (const sphere& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this),
  mesh_width_ (x.mesh_width_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this)
{
}

sphere::
sphere (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this),
  mesh_width_ (this),
  particleTypeId_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void sphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "mesh_width" && n.namespace_ ().empty ())
    {
      this->mesh_width_.set (mesh_width_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }
  }

  if (!mesh_width_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mesh_width",
      "");
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

sphere* sphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere (*this, f, c);
}

sphere& sphere::
operator= (const sphere& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
    this->mesh_width_ = x.mesh_width_;
    this->particleTypeId_ = x.particleTypeId_;
  }

  return *this;
}

sphere::
~sphere ()
{
}

// torus
//

torus::
torus (const coordinate_type& coordinate,
       const velocity_type& velocity,
       const major_radius_type& major_radius,
       const minor_radius_type& minor_radius,
       const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  major_radius_ (major_radius, this),
  minor_radius_ (minor_radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

torus::
torus (::std::unique_ptr< coordinate_type > coordinate,
       ::std::unique_ptr< velocity_type > velocity,
       const major_radius_type& major_radius,
       const minor_radius_type& minor_radius,
       const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  major_radius_ (major_radius, this),
  minor_radius_ (minor_radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

torus::
torus (const torus& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  major_radius_ (x.major_radius_, f, this),
  minor_radius_ (x.minor_radius_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this)
{
}

torus::
torus (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  major_radius_ (this),
  minor_radius_ (this),
  particleTypeId_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void torus::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // major_radius
    //
    if (n.name () == "major_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< major_radius_type > r (
        major_radius_traits::create (i, f, this));

      if (!major_radius_.present ())
      {
        this->major_radius_.set (::std::move (r));
        continue;
      }
    }

    // minor_radius
    //
    if (n.name () == "minor_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< minor_radius_type > r (
        minor_radius_traits::create (i, f, this));

      if (!minor_radius_.present ())
      {
        this->minor_radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!major_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "major_radius",
      "");
  }

  if (!minor_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minor_radius",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

torus* torus::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class torus (*this, f, c);
}

torus& torus::
operator= (const torus& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->major_radius_ = x.major_radius_;
    this->minor_radius_ = x.minor_radius_;
    this->particleTypeId_ = x.particleTypeId_;
  }

  return *this;
}

torus::
~torus ()
{
}

// double_helix
//

double_helix::
double_helix (const coordinate_type& coordinate,
              const velocity_type& velocity,
              const radius_type& radius,
              const pitch_type& pitch,
              const height_type& height,
              const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this),
  pitch_ (pitch, this),
  height_ (height, this),
  particleTypeId_ (particleTypeId, this)
{
}

double_helix::
double_helix (::std::unique_ptr< coordinate_type > coordinate,
              ::std::unique_ptr< velocity_type > velocity,
              const radius_type& radius,
              const pitch_type& pitch,
              const height_type& height,
              const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this),
  pitch_ (pitch, this),
  height_ (height, this),
  particleTypeId_ (particleTypeId, this)
{
}

double_helix::
double_helix (const double_helix& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this),
  pitch_ (x.pitch_, f, this),
  height_ (x.height_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this)
{
}

double_helix::
double_helix (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this),
  pitch_ (this),
  height_ (this),
  particleTypeId_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void double_helix::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    // pitch
    //
    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< pitch_type > r (
        pitch_traits::create (i, f, this));

      if (!pitch_.present ())
      {
        this->pitch_.set (::std::move (r));
        continue;
      }
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< height_type > r (
        height_traits::create (i, f, this));

      if (!height_.present ())
      {
        this->height_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!pitch_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pitch",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "height",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

double_helix* double_helix::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class double_helix (*this, f, c);
}

double_helix& double_helix::
operator= (const double_helix& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
    this->pitch_ = x.pitch_;
    this->height_ = x.height_;
    this->particleTypeId_ = x.particleTypeId_;
  }

  return *this;
}

double_helix::
~double_helix ()
{
}

// coordinate
//

coordinate::
coordinate (const x_type& x,
            const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

coordinate::
coordinate (const coordinate& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

coordinate::
coordinate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void coordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

coordinate* coordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class coordinate (*this, f, c);
}

coordinate& coordinate::
operator= (const coordinate& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

coordinate::
~coordinate ()
{
}

// velocity
//

velocity::
velocity (const x_type& x,
          const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

velocity::
velocity (const velocity& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

velocity::
velocity (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void velocity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

velocity* velocity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class velocity (*this, f, c);
}

velocity& velocity::
operator= (const velocity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

velocity::
~velocity ()
{
}

// dimensions
//

dimensions::
dimensions (const x_type& x,
            const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

dimensions::
dimensions (const dimensions& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

dimensions::
dimensions (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void dimensions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

dimensions* dimensions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dimensions (*this, f, c);
}

dimensions& dimensions::
operator= (const dimensions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

dimensions::
~dimensions ()
{
}

// positive_int
//

positive_int::
positive_int (const ::xml_schema::int_& _xsd_int__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (_xsd_int__base)
{
}

positive_int::
positive_int (const positive_int& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
{
}

positive_int::
positive_int (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
{
}

positive_int::
positive_int (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
{
}

positive_int::
positive_int (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

positive_int* positive_int::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positive_int (*this, f, c);
}

positive_int::
~positive_int ()
{
}

// positive_double
//

positive_double::
positive_double (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

positive_double::
positive_double (const positive_double& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

positive_double::
positive_double (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

positive_double::
positive_double (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

positive_double::
positive_double (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

positive_double* positive_double::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positive_double (*this, f, c);
}

positive_double::
~positive_double ()
{
}

// scenario
//

scenario::
scenario (const header_type& header,
          const container_type& container,
          const forces_type& forces)
: ::xml_schema::type (),
  header_ (header, this),
  checkpoints_ (this),
  thermostat_ (this),
  nanotube_ (this),
  container_ (container, this),
  forces_ (forces, this)
{
}

scenario::
scenario (::std::unique_ptr< header_type > header,
          ::std::unique_ptr< container_type > container,
          ::std::unique_ptr< forces_type > forces)
: ::xml_schema::type (),
  header_ (std::move (header), this),
  checkpoints_ (this),
  thermostat_ (this),
  nanotube_ (this),
  container_ (std::move (container), this),
  forces_ (std::move (forces), this)
{
}

scenario::
scenario (const scenario& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  header_ (x.header_, f, this),
  checkpoints_ (x.checkpoints_, f, this),
  thermostat_ (x.thermostat_, f, this),
  nanotube_ (x.nanotube_, f, this),
  container_ (x.container_, f, this),
  forces_ (x.forces_, f, this)
{
}

scenario::
scenario (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  header_ (this),
  checkpoints_ (this),
  thermostat_ (this),
  nanotube_ (this),
  container_ (this),
  forces_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void scenario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< header_type > r (
        header_traits::create (i, f, this));

      if (!header_.present ())
      {
        this->header_.set (::std::move (r));
        continue;
      }
    }

    // checkpoints
    //
    if (n.name () == "checkpoints" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< checkpoints_type > r (
        checkpoints_traits::create (i, f, this));

      if (!this->checkpoints_)
      {
        this->checkpoints_.set (::std::move (r));
        continue;
      }
    }

    // thermostat
    //
    if (n.name () == "thermostat" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< thermostat_type > r (
        thermostat_traits::create (i, f, this));

      if (!this->thermostat_)
      {
        this->thermostat_.set (::std::move (r));
        continue;
      }
    }

    // nanotube
    //
    if (n.name () == "nanotube" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< nanotube_type > r (
        nanotube_traits::create (i, f, this));

      if (!this->nanotube_)
      {
        this->nanotube_.set (::std::move (r));
        continue;
      }
    }

    // container
    //
    if (n.name () == "container" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< container_type > r (
        container_traits::create (i, f, this));

      if (!container_.present ())
      {
        this->container_.set (::std::move (r));
        continue;
      }
    }

    // forces
    //
    if (n.name () == "forces" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< forces_type > r (
        forces_traits::create (i, f, this));

      if (!forces_.present ())
      {
        this->forces_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!header_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "header",
      "");
  }

  if (!container_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "container",
      "");
  }

  if (!forces_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "forces",
      "");
  }
}

scenario* scenario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class scenario (*this, f, c);
}

scenario& scenario::
operator= (const scenario& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->header_ = x.header_;
    this->checkpoints_ = x.checkpoints_;
    this->thermostat_ = x.thermostat_;
    this->nanotube_ = x.nanotube_;
    this->container_ = x.container_;
    this->forces_ = x.forces_;
  }

  return *this;
}

scenario::
~scenario ()
{
}

// header
//

header::
header (const base_name_type& base_name,
        const t_end_type& t_end,
        const delta_t_type& delta_t,
        const output_frequency_type& output_frequency,
        const output_file_type& output_file,
        const seed_type& seed,
        const dimensions_type& dimensions,
        const parallelized_type& parallelized,
        const vectorized_type& vectorized)
: ::xml_schema::type (),
  base_name_ (base_name, this),
  t_start_ (this),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  output_frequency_ (output_frequency, this),
  output_file_ (output_file, this),
  seed_ (seed, this),
  dimensions_ (dimensions, this),
  parallelized_ (parallelized, this),
  vectorized_ (vectorized, this)
{
}

header::
header (const header& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  base_name_ (x.base_name_, f, this),
  t_start_ (x.t_start_, f, this),
  t_end_ (x.t_end_, f, this),
  delta_t_ (x.delta_t_, f, this),
  output_frequency_ (x.output_frequency_, f, this),
  output_file_ (x.output_file_, f, this),
  seed_ (x.seed_, f, this),
  dimensions_ (x.dimensions_, f, this),
  parallelized_ (x.parallelized_, f, this),
  vectorized_ (x.vectorized_, f, this)
{
}

header::
header (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  base_name_ (this),
  t_start_ (this),
  t_end_ (this),
  delta_t_ (this),
  output_frequency_ (this),
  output_file_ (this),
  seed_ (this),
  dimensions_ (this),
  parallelized_ (this),
  vectorized_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "base_name" && n.namespace_ ().empty ())
    {
      this->base_name_.set (base_name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t_start" && n.namespace_ ().empty ())
    {
      this->t_start_.set (t_start_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      this->t_end_.set (t_end_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      this->delta_t_.set (delta_t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_frequency" && n.namespace_ ().empty ())
    {
      this->output_frequency_.set (output_frequency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_file" && n.namespace_ ().empty ())
    {
      this->output_file_.set (output_file_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "seed" && n.namespace_ ().empty ())
    {
      this->seed_.set (seed_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      this->dimensions_.set (dimensions_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "parallelized" && n.namespace_ ().empty ())
    {
      this->parallelized_.set (parallelized_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "vectorized" && n.namespace_ ().empty ())
    {
      this->vectorized_.set (vectorized_traits::create (i, f, this));
      continue;
    }
  }

  if (!base_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "base_name",
      "");
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t_end",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "delta_t",
      "");
  }

  if (!output_frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_frequency",
      "");
  }

  if (!output_file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_file",
      "");
  }

  if (!seed_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "seed",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "dimensions",
      "");
  }

  if (!parallelized_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "parallelized",
      "");
  }

  if (!vectorized_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "vectorized",
      "");
  }
}

header* header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class header (*this, f, c);
}

header& header::
operator= (const header& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->base_name_ = x.base_name_;
    this->t_start_ = x.t_start_;
    this->t_end_ = x.t_end_;
    this->delta_t_ = x.delta_t_;
    this->output_frequency_ = x.output_frequency_;
    this->output_file_ = x.output_file_;
    this->seed_ = x.seed_;
    this->dimensions_ = x.dimensions_;
    this->parallelized_ = x.parallelized_;
    this->vectorized_ = x.vectorized_;
  }

  return *this;
}

header::
~header ()
{
}

// checkpoints
//

checkpoints::
checkpoints ()
: ::xml_schema::type (),
  checkpoint_ (this),
  path_ (this)
{
}

checkpoints::
checkpoints (const checkpoints& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  checkpoint_ (x.checkpoint_, f, this),
  path_ (x.path_, f, this)
{
}

checkpoints::
checkpoints (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  checkpoint_ (this),
  path_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void checkpoints::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // checkpoint
    //
    if (n.name () == "checkpoint" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< checkpoint_type > r (
        checkpoint_traits::create (i, f, this));

      this->checkpoint_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "path" && n.namespace_ ().empty ())
    {
      this->path_.set (path_traits::create (i, f, this));
      continue;
    }
  }
}

checkpoints* checkpoints::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class checkpoints (*this, f, c);
}

checkpoints& checkpoints::
operator= (const checkpoints& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->checkpoint_ = x.checkpoint_;
    this->path_ = x.path_;
  }

  return *this;
}

checkpoints::
~checkpoints ()
{
}

// thermostat
//

thermostat::
thermostat (const t_init_type& t_init,
            const frequency_type& frequency)
: ::xml_schema::type (),
  t_init_ (t_init, this),
  t_target_ (this),
  frequency_ (frequency, this),
  max_temp_diff_ (this),
  brownian_motion_ (this)
{
}

thermostat::
thermostat (const thermostat& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  t_init_ (x.t_init_, f, this),
  t_target_ (x.t_target_, f, this),
  frequency_ (x.frequency_, f, this),
  max_temp_diff_ (x.max_temp_diff_, f, this),
  brownian_motion_ (x.brownian_motion_, f, this)
{
}

thermostat::
thermostat (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  t_init_ (this),
  t_target_ (this),
  frequency_ (this),
  max_temp_diff_ (this),
  brownian_motion_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void thermostat::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "t_init" && n.namespace_ ().empty ())
    {
      this->t_init_.set (t_init_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t_target" && n.namespace_ ().empty ())
    {
      this->t_target_.set (t_target_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "frequency" && n.namespace_ ().empty ())
    {
      this->frequency_.set (frequency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "max_temp_diff" && n.namespace_ ().empty ())
    {
      this->max_temp_diff_.set (max_temp_diff_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "brownian_motion" && n.namespace_ ().empty ())
    {
      this->brownian_motion_.set (brownian_motion_traits::create (i, f, this));
      continue;
    }
  }

  if (!t_init_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t_init",
      "");
  }

  if (!frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "frequency",
      "");
  }
}

thermostat* thermostat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class thermostat (*this, f, c);
}

thermostat& thermostat::
operator= (const thermostat& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->t_init_ = x.t_init_;
    this->t_target_ = x.t_target_;
    this->frequency_ = x.frequency_;
    this->max_temp_diff_ = x.max_temp_diff_;
    this->brownian_motion_ = x.brownian_motion_;
  }

  return *this;
}

thermostat::
~thermostat ()
{
}

// nanotube
//

nanotube::
nanotube (const n_bins_type& n_bins,
          const iterations_type& iterations)
: ::xml_schema::type (),
  n_bins_ (n_bins, this),
  iterations_ (iterations, this)
{
}

nanotube::
nanotube (const nanotube& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  n_bins_ (x.n_bins_, f, this),
  iterations_ (x.iterations_, f, this)
{
}

nanotube::
nanotube (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  n_bins_ (this),
  iterations_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void nanotube::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "n_bins" && n.namespace_ ().empty ())
    {
      this->n_bins_.set (n_bins_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "iterations" && n.namespace_ ().empty ())
    {
      this->iterations_.set (iterations_traits::create (i, f, this));
      continue;
    }
  }

  if (!n_bins_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "n_bins",
      "");
  }

  if (!iterations_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "iterations",
      "");
  }
}

nanotube* nanotube::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class nanotube (*this, f, c);
}

nanotube& nanotube::
operator= (const nanotube& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->n_bins_ = x.n_bins_;
    this->iterations_ = x.iterations_;
  }

  return *this;
}

nanotube::
~nanotube ()
{
}

// container
//

const container::vector_type container::vector_default_value_ (
  "");

container::
container ()
: ::xml_schema::type (),
  linked_cells_ (this),
  vector_ (this)
{
}

container::
container (const container& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  linked_cells_ (x.linked_cells_, f, this),
  vector_ (x.vector_, f, this)
{
}

container::
container (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  linked_cells_ (this),
  vector_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void container::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // linked_cells
    //
    if (n.name () == "linked_cells" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< linked_cells_type > r (
        linked_cells_traits::create (i, f, this));

      if (!this->linked_cells_)
      {
        this->linked_cells_.set (::std::move (r));
        continue;
      }
    }

    // vector
    //
    if (n.name () == "vector" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< vector_type > r (
        vector_traits::create (i, f, this));

      if (!this->vector_)
      {
        this->vector_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

container* container::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class container (*this, f, c);
}

container& container::
operator= (const container& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->linked_cells_ = x.linked_cells_;
    this->vector_ = x.vector_;
  }

  return *this;
}

container::
~container ()
{
}

// forces
//

forces::
forces ()
: ::xml_schema::type (),
  gravity_ (this),
  lennard_jones_ (this)
{
}

forces::
forces (const forces& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  gravity_ (x.gravity_, f, this),
  lennard_jones_ (x.lennard_jones_, f, this)
{
}

forces::
forces (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  gravity_ (this),
  lennard_jones_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void forces::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      if (!this->gravity_)
      {
        this->gravity_.set (gravity_traits::create (i, f, this));
        continue;
      }
    }

    // lennard_jones
    //
    if (n.name () == "lennard_jones" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lennard_jones_type > r (
        lennard_jones_traits::create (i, f, this));

      if (!this->lennard_jones_)
      {
        this->lennard_jones_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

forces* forces::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class forces (*this, f, c);
}

forces& forces::
operator= (const forces& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->gravity_ = x.gravity_;
    this->lennard_jones_ = x.lennard_jones_;
  }

  return *this;
}

forces::
~forces ()
{
}

// linked_cells
//

linked_cells::
linked_cells (const domain_size_type& domain_size,
              const boundary_conditions_type& boundary_conditions,
              const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  domain_size_ (domain_size, this),
  boundary_conditions_ (boundary_conditions, this),
  cutoff_radius_ (cutoff_radius, this)
{
}

linked_cells::
linked_cells (::std::unique_ptr< domain_size_type > domain_size,
              ::std::unique_ptr< boundary_conditions_type > boundary_conditions,
              const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  domain_size_ (std::move (domain_size), this),
  boundary_conditions_ (std::move (boundary_conditions), this),
  cutoff_radius_ (cutoff_radius, this)
{
}

linked_cells::
linked_cells (const linked_cells& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  domain_size_ (x.domain_size_, f, this),
  boundary_conditions_ (x.boundary_conditions_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this)
{
}

linked_cells::
linked_cells (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  domain_size_ (this),
  boundary_conditions_ (this),
  cutoff_radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void linked_cells::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (::std::move (r));
        continue;
      }
    }

    // boundary_conditions
    //
    if (n.name () == "boundary_conditions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_conditions_type > r (
        boundary_conditions_traits::create (i, f, this));

      if (!boundary_conditions_.present ())
      {
        this->boundary_conditions_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain_size",
      "");
  }

  if (!boundary_conditions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary_conditions",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      this->cutoff_radius_.set (cutoff_radius_traits::create (i, f, this));
      continue;
    }
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cutoff_radius",
      "");
  }
}

linked_cells* linked_cells::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class linked_cells (*this, f, c);
}

linked_cells& linked_cells::
operator= (const linked_cells& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->domain_size_ = x.domain_size_;
    this->boundary_conditions_ = x.boundary_conditions_;
    this->cutoff_radius_ = x.cutoff_radius_;
  }

  return *this;
}

linked_cells::
~linked_cells ()
{
}

// lennard_jones
//

lennard_jones::
lennard_jones (const particleTypes_type& particleTypes)
: ::xml_schema::type (),
  particleTypes_ (particleTypes, this),
  gravity_ (this),
  particles_ (this)
{
}

lennard_jones::
lennard_jones (::std::unique_ptr< particleTypes_type > particleTypes)
: ::xml_schema::type (),
  particleTypes_ (std::move (particleTypes), this),
  gravity_ (this),
  particles_ (this)
{
}

lennard_jones::
lennard_jones (const lennard_jones& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particleTypes_ (x.particleTypes_, f, this),
  gravity_ (x.gravity_, f, this),
  particles_ (x.particles_, f, this)
{
}

lennard_jones::
lennard_jones (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particleTypes_ (this),
  gravity_ (this),
  particles_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lennard_jones::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particleTypes
    //
    if (n.name () == "particleTypes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particleTypes_type > r (
        particleTypes_traits::create (i, f, this));

      if (!particleTypes_.present ())
      {
        this->particleTypes_.set (::std::move (r));
        continue;
      }
    }

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      if (!this->gravity_)
      {
        this->gravity_.set (gravity_traits::create (i, f, this));
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      if (!this->particles_)
      {
        this->particles_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!particleTypes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particleTypes",
      "");
  }
}

lennard_jones* lennard_jones::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lennard_jones (*this, f, c);
}

lennard_jones& lennard_jones::
operator= (const lennard_jones& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particleTypes_ = x.particleTypes_;
    this->gravity_ = x.gravity_;
    this->particles_ = x.particles_;
  }

  return *this;
}

lennard_jones::
~lennard_jones ()
{
}

// domain_size
//

domain_size::
domain_size (const x_type& x,
             const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

domain_size::
domain_size (const domain_size& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

domain_size::
domain_size (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void domain_size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

domain_size* domain_size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class domain_size (*this, f, c);
}

domain_size& domain_size::
operator= (const domain_size& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

domain_size::
~domain_size ()
{
}

// boundary_conditions
//

boundary_conditions::
boundary_conditions ()
: ::xml_schema::type (),
  boundary_condition_ (this)
{
}

boundary_conditions::
boundary_conditions (const boundary_conditions& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  boundary_condition_ (x.boundary_condition_, f, this)
{
}

boundary_conditions::
boundary_conditions (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  boundary_condition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundary_conditions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // boundary_condition
    //
    if (n.name () == "boundary_condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_condition_type > r (
        boundary_condition_traits::create (i, f, this));

      this->boundary_condition_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

boundary_conditions* boundary_conditions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_conditions (*this, f, c);
}

boundary_conditions& boundary_conditions::
operator= (const boundary_conditions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->boundary_condition_ = x.boundary_condition_;
  }

  return *this;
}

boundary_conditions::
~boundary_conditions ()
{
}

// particleTypes
//

particleTypes::
particleTypes ()
: ::xml_schema::type (),
  particleType_ (this)
{
}

particleTypes::
particleTypes (const particleTypes& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particleType_ (x.particleType_, f, this)
{
}

particleTypes::
particleTypes (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particleType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particleTypes::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particleType
    //
    if (n.name () == "particleType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particleType_type > r (
        particleType_traits::create (i, f, this));

      this->particleType_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

particleTypes* particleTypes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particleTypes (*this, f, c);
}

particleTypes& particleTypes::
operator= (const particleTypes& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particleType_ = x.particleType_;
  }

  return *this;
}

particleTypes::
~particleTypes ()
{
}

// particles
//

particles::
particles ()
: ::xml_schema::type (),
  cuboid_ (this),
  disc_ (this),
  sphere_ (this),
  torus_ (this),
  doubleHelix_ (this)
{
}

particles::
particles (const particles& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cuboid_ (x.cuboid_, f, this),
  disc_ (x.disc_, f, this),
  sphere_ (x.sphere_, f, this),
  torus_ (x.torus_, f, this),
  doubleHelix_ (x.doubleHelix_, f, this)
{
}

particles::
particles (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cuboid_ (this),
  disc_ (this),
  sphere_ (this),
  torus_ (this),
  doubleHelix_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (::std::move (r));
      continue;
    }

    // disc
    //
    if (n.name () == "disc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< disc_type > r (
        disc_traits::create (i, f, this));

      this->disc_.push_back (::std::move (r));
      continue;
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      this->sphere_.push_back (::std::move (r));
      continue;
    }

    // torus
    //
    if (n.name () == "torus" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< torus_type > r (
        torus_traits::create (i, f, this));

      this->torus_.push_back (::std::move (r));
      continue;
    }

    // doubleHelix
    //
    if (n.name () == "doubleHelix" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< doubleHelix_type > r (
        doubleHelix_traits::create (i, f, this));

      this->doubleHelix_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

particles* particles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particles (*this, f, c);
}

particles& particles::
operator= (const particles& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cuboid_ = x.cuboid_;
    this->disc_ = x.disc_;
    this->sphere_ = x.sphere_;
    this->torus_ = x.torus_;
    this->doubleHelix_ = x.doubleHelix_;
  }

  return *this;
}

particles::
~particles ()
{
}

// boundary_condition
//

boundary_condition::
boundary_condition (const type_type& type)
: ::xml_schema::type (),
  type_ (type, this)
{
}

boundary_condition::
boundary_condition (const boundary_condition& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this)
{
}

boundary_condition::
boundary_condition (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void boundary_condition::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

boundary_condition* boundary_condition::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_condition (*this, f, c);
}

boundary_condition& boundary_condition::
operator= (const boundary_condition& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

boundary_condition::
~boundary_condition ()
{
}

// particleType
//

particleType::
particleType (const id_type& id,
              const sigma_type& sigma,
              const epsilon_type& epsilon,
              const mass_type& mass)
: ::xml_schema::type (),
  id_ (id, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this),
  mass_ (mass, this)
{
}

particleType::
particleType (const particleType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this),
  mass_ (x.mass_, f, this)
{
}

particleType::
particleType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this),
  sigma_ (this),
  epsilon_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void particleType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (sigma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (epsilon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (mass_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "epsilon",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mass",
      "");
  }
}

particleType* particleType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particleType (*this, f, c);
}

particleType& particleType::
operator= (const particleType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
    this->mass_ = x.mass_;
  }

  return *this;
}

particleType::
~particleType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::scenario >
scenario_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scenario_ (isrc, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scenario_ (isrc, h, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scenario_ (isrc, h, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scenario_ (isrc, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scenario_ (isrc, h, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scenario_ (isrc, h, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::scenario > (
      ::scenario_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "scenario" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::scenario > r (
      ::xsd::cxx::tree::traits< ::scenario, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "scenario",
    "");
}

::std::unique_ptr< ::scenario >
scenario_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "scenario" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::scenario > r (
      ::xsd::cxx::tree::traits< ::scenario, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "scenario",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
scenario_ (::std::ostream& o,
           const ::scenario& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::scenario_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
scenario_ (::std::ostream& o,
           const ::scenario& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::scenario_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
scenario_ (::std::ostream& o,
           const ::scenario& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::scenario_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
scenario_ (::xercesc::XMLFormatTarget& t,
           const ::scenario& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::scenario_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
scenario_ (::xercesc::XMLFormatTarget& t,
           const ::scenario& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::scenario_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
scenario_ (::xercesc::XMLFormatTarget& t,
           const ::scenario& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::scenario_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
scenario_ (::xercesc::DOMDocument& d,
           const ::scenario& s,
           ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "scenario" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "scenario",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
scenario_ (const ::scenario& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "scenario",
      "",
      m, f));

  ::scenario_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const celestial_body& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << i.mass ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const cuboid& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // dimensions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dimensions",
        e));

    s << i.dimensions ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // particleTypeId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "particleTypeId",
        e));

    a << i.particleTypeId ();
  }

  // spacing
  //
  if (i.spacing ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "spacing",
        e));

    a << ::xml_schema::as_double(*i.spacing ());
  }

  // fixed
  //
  if (i.fixed ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "fixed",
        e));

    a << *i.fixed ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const disc& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << i.radius ();
  }

  // particleTypeId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "particleTypeId",
        e));

    a << i.particleTypeId ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const sphere& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << i.radius ();
  }

  // mesh_width
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "mesh_width",
        e));

    a << ::xml_schema::as_double(i.mesh_width ());
  }

  // particleTypeId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "particleTypeId",
        e));

    a << i.particleTypeId ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const torus& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // major_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "major_radius",
        e));

    s << i.major_radius ();
  }

  // minor_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "minor_radius",
        e));

    s << i.minor_radius ();
  }

  // particleTypeId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "particleTypeId",
        e));

    a << i.particleTypeId ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const double_helix& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << i.radius ();
  }

  // pitch
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "pitch",
        e));

    s << i.pitch ();
  }

  // height
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "height",
        e));

    s << i.height ();
  }

  // particleTypeId
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "particleTypeId",
        e));

    a << i.particleTypeId ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const coordinate& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(*i.z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const velocity& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(*i.z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const dimensions& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(*i.z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const positive_int& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const positive_int& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const positive_int& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const positive_double& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const positive_double& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const positive_double& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const scenario& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // header
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "header",
        e));

    s << i.header ();
  }

  // checkpoints
  //
  if (i.checkpoints ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "checkpoints",
        e));

    s << *i.checkpoints ();
  }

  // thermostat
  //
  if (i.thermostat ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "thermostat",
        e));

    s << *i.thermostat ();
  }

  // nanotube
  //
  if (i.nanotube ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "nanotube",
        e));

    s << *i.nanotube ();
  }

  // container
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "container",
        e));

    s << i.container ();
  }

  // forces
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "forces",
        e));

    s << i.forces ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const header& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // base_name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "base_name",
        e));

    a << i.base_name ();
  }

  // t_start
  //
  if (i.t_start ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t_start",
        e));

    a << *i.t_start ();
  }

  // t_end
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t_end",
        e));

    a << i.t_end ();
  }

  // delta_t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "delta_t",
        e));

    a << ::xml_schema::as_double(i.delta_t ());
  }

  // output_frequency
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "output_frequency",
        e));

    a << i.output_frequency ();
  }

  // output_file
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "output_file",
        e));

    a << i.output_file ();
  }

  // seed
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "seed",
        e));

    a << i.seed ();
  }

  // dimensions
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "dimensions",
        e));

    a << i.dimensions ();
  }

  // parallelized
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "parallelized",
        e));

    a << i.parallelized ();
  }

  // vectorized
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "vectorized",
        e));

    a << i.vectorized ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const checkpoints& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // checkpoint
  //
  for (checkpoints::checkpoint_const_iterator
       b (i.checkpoint ().begin ()), n (i.checkpoint ().end ());
       b != n; ++b)
  {
    const checkpoints::checkpoint_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "checkpoint",
        e));

    s << x;
  }

  // path
  //
  if (i.path ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "path",
        e));

    a << *i.path ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const thermostat& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // t_init
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t_init",
        e));

    a << ::xml_schema::as_double(i.t_init ());
  }

  // t_target
  //
  if (i.t_target ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t_target",
        e));

    a << ::xml_schema::as_double(*i.t_target ());
  }

  // frequency
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "frequency",
        e));

    a << i.frequency ();
  }

  // max_temp_diff
  //
  if (i.max_temp_diff ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "max_temp_diff",
        e));

    a << ::xml_schema::as_double(*i.max_temp_diff ());
  }

  // brownian_motion
  //
  if (i.brownian_motion ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "brownian_motion",
        e));

    a << ::xml_schema::as_double(*i.brownian_motion ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const nanotube& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // n_bins
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "n_bins",
        e));

    a << i.n_bins ();
  }

  // iterations
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "iterations",
        e));

    a << i.iterations ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const container& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // linked_cells
  //
  if (i.linked_cells ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "linked_cells",
        e));

    s << *i.linked_cells ();
  }

  // vector
  //
  if (i.vector ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vector",
        e));

    s << *i.vector ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const forces& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // gravity
  //
  if (i.gravity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "gravity",
        e));

    s << ::xml_schema::as_double(*i.gravity ());
  }

  // lennard_jones
  //
  if (i.lennard_jones ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "lennard_jones",
        e));

    s << *i.lennard_jones ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const linked_cells& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // domain_size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "domain_size",
        e));

    s << i.domain_size ();
  }

  // boundary_conditions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "boundary_conditions",
        e));

    s << i.boundary_conditions ();
  }

  // cutoff_radius
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "cutoff_radius",
        e));

    a << i.cutoff_radius ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const lennard_jones& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // particleTypes
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "particleTypes",
        e));

    s << i.particleTypes ();
  }

  // gravity
  //
  if (i.gravity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "gravity",
        e));

    s << ::xml_schema::as_double(*i.gravity ());
  }

  // particles
  //
  if (i.particles ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "particles",
        e));

    s << *i.particles ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const domain_size& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  if (i.z ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(*i.z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const boundary_conditions& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // boundary_condition
  //
  for (boundary_conditions::boundary_condition_const_iterator
       b (i.boundary_condition ().begin ()), n (i.boundary_condition ().end ());
       b != n; ++b)
  {
    const boundary_conditions::boundary_condition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "boundary_condition",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const particleTypes& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // particleType
  //
  for (particleTypes::particleType_const_iterator
       b (i.particleType ().begin ()), n (i.particleType ().end ());
       b != n; ++b)
  {
    const particleTypes::particleType_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "particleType",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const particles& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // cuboid
  //
  for (particles::cuboid_const_iterator
       b (i.cuboid ().begin ()), n (i.cuboid ().end ());
       b != n; ++b)
  {
    const particles::cuboid_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cuboid",
        e));

    s << x;
  }

  // disc
  //
  for (particles::disc_const_iterator
       b (i.disc ().begin ()), n (i.disc ().end ());
       b != n; ++b)
  {
    const particles::disc_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "disc",
        e));

    s << x;
  }

  // sphere
  //
  for (particles::sphere_const_iterator
       b (i.sphere ().begin ()), n (i.sphere ().end ());
       b != n; ++b)
  {
    const particles::sphere_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sphere",
        e));

    s << x;
  }

  // torus
  //
  for (particles::torus_const_iterator
       b (i.torus ().begin ()), n (i.torus ().end ());
       b != n; ++b)
  {
    const particles::torus_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "torus",
        e));

    s << x;
  }

  // doubleHelix
  //
  for (particles::doubleHelix_const_iterator
       b (i.doubleHelix ().begin ()), n (i.doubleHelix ().end ());
       b != n; ++b)
  {
    const particles::doubleHelix_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "doubleHelix",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const boundary_condition& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const particleType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }

  // sigma
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sigma",
        e));

    a << ::xml_schema::as_double(i.sigma ());
  }

  // epsilon
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "epsilon",
        e));

    a << ::xml_schema::as_double(i.epsilon ());
  }

  // mass
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "mass",
        e));

    a << ::xml_schema::as_double(i.mass ());
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

