// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SimulationInputSchema.hxx"

// celestial_body
//

const celestial_body::coordinate_type& celestial_body::
coordinate () const
{
  return this->coordinate_.get ();
}

celestial_body::coordinate_type& celestial_body::
coordinate ()
{
  return this->coordinate_.get ();
}

void celestial_body::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void celestial_body::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const celestial_body::velocity_type& celestial_body::
velocity () const
{
  return this->velocity_.get ();
}

celestial_body::velocity_type& celestial_body::
velocity ()
{
  return this->velocity_.get ();
}

void celestial_body::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void celestial_body::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const celestial_body::mass_type& celestial_body::
mass () const
{
  return this->mass_.get ();
}

celestial_body::mass_type& celestial_body::
mass ()
{
  return this->mass_.get ();
}

void celestial_body::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void celestial_body::
mass (::std::unique_ptr< mass_type > x)
{
  this->mass_.set (std::move (x));
}


// cuboid
//

const cuboid::coordinate_type& cuboid::
coordinate () const
{
  return this->coordinate_.get ();
}

cuboid::coordinate_type& cuboid::
coordinate ()
{
  return this->coordinate_.get ();
}

void cuboid::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void cuboid::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const cuboid::dimensions_type& cuboid::
dimensions () const
{
  return this->dimensions_.get ();
}

cuboid::dimensions_type& cuboid::
dimensions ()
{
  return this->dimensions_.get ();
}

void cuboid::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

void cuboid::
dimensions (::std::unique_ptr< dimensions_type > x)
{
  this->dimensions_.set (std::move (x));
}

const cuboid::velocity_type& cuboid::
velocity () const
{
  return this->velocity_.get ();
}

cuboid::velocity_type& cuboid::
velocity ()
{
  return this->velocity_.get ();
}

void cuboid::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboid::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const cuboid::particleTypeId_type& cuboid::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

cuboid::particleTypeId_type& cuboid::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void cuboid::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}

const cuboid::spacing_optional& cuboid::
spacing () const
{
  return this->spacing_;
}

cuboid::spacing_optional& cuboid::
spacing ()
{
  return this->spacing_;
}

void cuboid::
spacing (const spacing_type& x)
{
  this->spacing_.set (x);
}

void cuboid::
spacing (const spacing_optional& x)
{
  this->spacing_ = x;
}


// disc
//

const disc::coordinate_type& disc::
coordinate () const
{
  return this->coordinate_.get ();
}

disc::coordinate_type& disc::
coordinate ()
{
  return this->coordinate_.get ();
}

void disc::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void disc::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const disc::velocity_type& disc::
velocity () const
{
  return this->velocity_.get ();
}

disc::velocity_type& disc::
velocity ()
{
  return this->velocity_.get ();
}

void disc::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void disc::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const disc::radius_type& disc::
radius () const
{
  return this->radius_.get ();
}

disc::radius_type& disc::
radius ()
{
  return this->radius_.get ();
}

void disc::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void disc::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}

const disc::particleTypeId_type& disc::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

disc::particleTypeId_type& disc::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void disc::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}


// sphere
//

const sphere::coordinate_type& sphere::
coordinate () const
{
  return this->coordinate_.get ();
}

sphere::coordinate_type& sphere::
coordinate ()
{
  return this->coordinate_.get ();
}

void sphere::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void sphere::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const sphere::velocity_type& sphere::
velocity () const
{
  return this->velocity_.get ();
}

sphere::velocity_type& sphere::
velocity ()
{
  return this->velocity_.get ();
}

void sphere::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void sphere::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const sphere::radius_type& sphere::
radius () const
{
  return this->radius_.get ();
}

sphere::radius_type& sphere::
radius ()
{
  return this->radius_.get ();
}

void sphere::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void sphere::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}

const sphere::particleTypeId_type& sphere::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

sphere::particleTypeId_type& sphere::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void sphere::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}


// torus
//

const torus::coordinate_type& torus::
coordinate () const
{
  return this->coordinate_.get ();
}

torus::coordinate_type& torus::
coordinate ()
{
  return this->coordinate_.get ();
}

void torus::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void torus::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const torus::velocity_type& torus::
velocity () const
{
  return this->velocity_.get ();
}

torus::velocity_type& torus::
velocity ()
{
  return this->velocity_.get ();
}

void torus::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void torus::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const torus::major_radius_type& torus::
major_radius () const
{
  return this->major_radius_.get ();
}

torus::major_radius_type& torus::
major_radius ()
{
  return this->major_radius_.get ();
}

void torus::
major_radius (const major_radius_type& x)
{
  this->major_radius_.set (x);
}

void torus::
major_radius (::std::unique_ptr< major_radius_type > x)
{
  this->major_radius_.set (std::move (x));
}

const torus::minor_radius_type& torus::
minor_radius () const
{
  return this->minor_radius_.get ();
}

torus::minor_radius_type& torus::
minor_radius ()
{
  return this->minor_radius_.get ();
}

void torus::
minor_radius (const minor_radius_type& x)
{
  this->minor_radius_.set (x);
}

void torus::
minor_radius (::std::unique_ptr< minor_radius_type > x)
{
  this->minor_radius_.set (std::move (x));
}

const torus::particleTypeId_type& torus::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

torus::particleTypeId_type& torus::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void torus::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}


// double_helix
//

const double_helix::coordinate_type& double_helix::
coordinate () const
{
  return this->coordinate_.get ();
}

double_helix::coordinate_type& double_helix::
coordinate ()
{
  return this->coordinate_.get ();
}

void double_helix::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void double_helix::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const double_helix::velocity_type& double_helix::
velocity () const
{
  return this->velocity_.get ();
}

double_helix::velocity_type& double_helix::
velocity ()
{
  return this->velocity_.get ();
}

void double_helix::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void double_helix::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const double_helix::radius_type& double_helix::
radius () const
{
  return this->radius_.get ();
}

double_helix::radius_type& double_helix::
radius ()
{
  return this->radius_.get ();
}

void double_helix::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void double_helix::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}

const double_helix::pitch_type& double_helix::
pitch () const
{
  return this->pitch_.get ();
}

double_helix::pitch_type& double_helix::
pitch ()
{
  return this->pitch_.get ();
}

void double_helix::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void double_helix::
pitch (::std::unique_ptr< pitch_type > x)
{
  this->pitch_.set (std::move (x));
}

const double_helix::height_type& double_helix::
height () const
{
  return this->height_.get ();
}

double_helix::height_type& double_helix::
height ()
{
  return this->height_.get ();
}

void double_helix::
height (const height_type& x)
{
  this->height_.set (x);
}

void double_helix::
height (::std::unique_ptr< height_type > x)
{
  this->height_.set (std::move (x));
}

const double_helix::particleTypeId_type& double_helix::
particleTypeId () const
{
  return this->particleTypeId_.get ();
}

double_helix::particleTypeId_type& double_helix::
particleTypeId ()
{
  return this->particleTypeId_.get ();
}

void double_helix::
particleTypeId (const particleTypeId_type& x)
{
  this->particleTypeId_.set (x);
}


// coordinate
//

const coordinate::x_type& coordinate::
x () const
{
  return this->x_.get ();
}

coordinate::x_type& coordinate::
x ()
{
  return this->x_.get ();
}

void coordinate::
x (const x_type& x)
{
  this->x_.set (x);
}

const coordinate::y_type& coordinate::
y () const
{
  return this->y_.get ();
}

coordinate::y_type& coordinate::
y ()
{
  return this->y_.get ();
}

void coordinate::
y (const y_type& x)
{
  this->y_.set (x);
}

const coordinate::z_optional& coordinate::
z () const
{
  return this->z_;
}

coordinate::z_optional& coordinate::
z ()
{
  return this->z_;
}

void coordinate::
z (const z_type& x)
{
  this->z_.set (x);
}

void coordinate::
z (const z_optional& x)
{
  this->z_ = x;
}


// velocity
//

const velocity::x_type& velocity::
x () const
{
  return this->x_.get ();
}

velocity::x_type& velocity::
x ()
{
  return this->x_.get ();
}

void velocity::
x (const x_type& x)
{
  this->x_.set (x);
}

const velocity::y_type& velocity::
y () const
{
  return this->y_.get ();
}

velocity::y_type& velocity::
y ()
{
  return this->y_.get ();
}

void velocity::
y (const y_type& x)
{
  this->y_.set (x);
}

const velocity::z_optional& velocity::
z () const
{
  return this->z_;
}

velocity::z_optional& velocity::
z ()
{
  return this->z_;
}

void velocity::
z (const z_type& x)
{
  this->z_.set (x);
}

void velocity::
z (const z_optional& x)
{
  this->z_ = x;
}


// dimensions
//

const dimensions::x_type& dimensions::
x () const
{
  return this->x_.get ();
}

dimensions::x_type& dimensions::
x ()
{
  return this->x_.get ();
}

void dimensions::
x (const x_type& x)
{
  this->x_.set (x);
}

const dimensions::y_type& dimensions::
y () const
{
  return this->y_.get ();
}

dimensions::y_type& dimensions::
y ()
{
  return this->y_.get ();
}

void dimensions::
y (const y_type& x)
{
  this->y_.set (x);
}

const dimensions::z_optional& dimensions::
z () const
{
  return this->z_;
}

dimensions::z_optional& dimensions::
z ()
{
  return this->z_;
}

void dimensions::
z (const z_type& x)
{
  this->z_.set (x);
}

void dimensions::
z (const z_optional& x)
{
  this->z_ = x;
}


// positive_int
//


// positive_double
//


// scenario
//

const scenario::header_type& scenario::
header () const
{
  return this->header_.get ();
}

scenario::header_type& scenario::
header ()
{
  return this->header_.get ();
}

void scenario::
header (const header_type& x)
{
  this->header_.set (x);
}

void scenario::
header (::std::unique_ptr< header_type > x)
{
  this->header_.set (std::move (x));
}

const scenario::thermostat_optional& scenario::
thermostat () const
{
  return this->thermostat_;
}

scenario::thermostat_optional& scenario::
thermostat ()
{
  return this->thermostat_;
}

void scenario::
thermostat (const thermostat_type& x)
{
  this->thermostat_.set (x);
}

void scenario::
thermostat (const thermostat_optional& x)
{
  this->thermostat_ = x;
}

void scenario::
thermostat (::std::unique_ptr< thermostat_type > x)
{
  this->thermostat_.set (std::move (x));
}

const scenario::container_type& scenario::
container () const
{
  return this->container_.get ();
}

scenario::container_type& scenario::
container ()
{
  return this->container_.get ();
}

void scenario::
container (const container_type& x)
{
  this->container_.set (x);
}

void scenario::
container (::std::unique_ptr< container_type > x)
{
  this->container_.set (std::move (x));
}

const scenario::forces_type& scenario::
forces () const
{
  return this->forces_.get ();
}

scenario::forces_type& scenario::
forces ()
{
  return this->forces_.get ();
}

void scenario::
forces (const forces_type& x)
{
  this->forces_.set (x);
}

void scenario::
forces (::std::unique_ptr< forces_type > x)
{
  this->forces_.set (std::move (x));
}


// header
//

const header::base_name_type& header::
base_name () const
{
  return this->base_name_.get ();
}

header::base_name_type& header::
base_name ()
{
  return this->base_name_.get ();
}

void header::
base_name (const base_name_type& x)
{
  this->base_name_.set (x);
}

void header::
base_name (::std::unique_ptr< base_name_type > x)
{
  this->base_name_.set (std::move (x));
}

const header::t_start_optional& header::
t_start () const
{
  return this->t_start_;
}

header::t_start_optional& header::
t_start ()
{
  return this->t_start_;
}

void header::
t_start (const t_start_type& x)
{
  this->t_start_.set (x);
}

void header::
t_start (const t_start_optional& x)
{
  this->t_start_ = x;
}

void header::
t_start (::std::unique_ptr< t_start_type > x)
{
  this->t_start_.set (std::move (x));
}

const header::t_end_type& header::
t_end () const
{
  return this->t_end_.get ();
}

header::t_end_type& header::
t_end ()
{
  return this->t_end_.get ();
}

void header::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

void header::
t_end (::std::unique_ptr< t_end_type > x)
{
  this->t_end_.set (std::move (x));
}

const header::delta_t_type& header::
delta_t () const
{
  return this->delta_t_.get ();
}

header::delta_t_type& header::
delta_t ()
{
  return this->delta_t_.get ();
}

void header::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const header::output_frequency_type& header::
output_frequency () const
{
  return this->output_frequency_.get ();
}

header::output_frequency_type& header::
output_frequency ()
{
  return this->output_frequency_.get ();
}

void header::
output_frequency (const output_frequency_type& x)
{
  this->output_frequency_.set (x);
}

void header::
output_frequency (::std::unique_ptr< output_frequency_type > x)
{
  this->output_frequency_.set (std::move (x));
}

const header::output_file_type& header::
output_file () const
{
  return this->output_file_.get ();
}

header::output_file_type& header::
output_file ()
{
  return this->output_file_.get ();
}

void header::
output_file (const output_file_type& x)
{
  this->output_file_.set (x);
}

void header::
output_file (::std::unique_ptr< output_file_type > x)
{
  this->output_file_.set (std::move (x));
}

const header::seed_type& header::
seed () const
{
  return this->seed_.get ();
}

header::seed_type& header::
seed ()
{
  return this->seed_.get ();
}

void header::
seed (const seed_type& x)
{
  this->seed_.set (x);
}


// thermostat
//

const thermostat::t_init_type& thermostat::
t_init () const
{
  return this->t_init_.get ();
}

thermostat::t_init_type& thermostat::
t_init ()
{
  return this->t_init_.get ();
}

void thermostat::
t_init (const t_init_type& x)
{
  this->t_init_.set (x);
}

const thermostat::t_target_optional& thermostat::
t_target () const
{
  return this->t_target_;
}

thermostat::t_target_optional& thermostat::
t_target ()
{
  return this->t_target_;
}

void thermostat::
t_target (const t_target_type& x)
{
  this->t_target_.set (x);
}

void thermostat::
t_target (const t_target_optional& x)
{
  this->t_target_ = x;
}

const thermostat::frequency_type& thermostat::
frequency () const
{
  return this->frequency_.get ();
}

thermostat::frequency_type& thermostat::
frequency ()
{
  return this->frequency_.get ();
}

void thermostat::
frequency (const frequency_type& x)
{
  this->frequency_.set (x);
}

const thermostat::max_temp_diff_optional& thermostat::
max_temp_diff () const
{
  return this->max_temp_diff_;
}

thermostat::max_temp_diff_optional& thermostat::
max_temp_diff ()
{
  return this->max_temp_diff_;
}

void thermostat::
max_temp_diff (const max_temp_diff_type& x)
{
  this->max_temp_diff_.set (x);
}

void thermostat::
max_temp_diff (const max_temp_diff_optional& x)
{
  this->max_temp_diff_ = x;
}

const thermostat::brownian_motion_optional& thermostat::
brownian_motion () const
{
  return this->brownian_motion_;
}

thermostat::brownian_motion_optional& thermostat::
brownian_motion ()
{
  return this->brownian_motion_;
}

void thermostat::
brownian_motion (const brownian_motion_type& x)
{
  this->brownian_motion_.set (x);
}

void thermostat::
brownian_motion (const brownian_motion_optional& x)
{
  this->brownian_motion_ = x;
}


// container
//

const container::linked_cells_optional& container::
linked_cells () const
{
  return this->linked_cells_;
}

container::linked_cells_optional& container::
linked_cells ()
{
  return this->linked_cells_;
}

void container::
linked_cells (const linked_cells_type& x)
{
  this->linked_cells_.set (x);
}

void container::
linked_cells (const linked_cells_optional& x)
{
  this->linked_cells_ = x;
}

void container::
linked_cells (::std::unique_ptr< linked_cells_type > x)
{
  this->linked_cells_.set (std::move (x));
}

const container::vector_optional& container::
vector () const
{
  return this->vector_;
}

container::vector_optional& container::
vector ()
{
  return this->vector_;
}

void container::
vector (const vector_type& x)
{
  this->vector_.set (x);
}

void container::
vector (const vector_optional& x)
{
  this->vector_ = x;
}

void container::
vector (::std::unique_ptr< vector_type > x)
{
  this->vector_.set (std::move (x));
}

const container::vector_type& container::
vector_default_value ()
{
  return vector_default_value_;
}


// forces
//

const forces::gravity_optional& forces::
gravity () const
{
  return this->gravity_;
}

forces::gravity_optional& forces::
gravity ()
{
  return this->gravity_;
}

void forces::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void forces::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

void forces::
gravity (::std::unique_ptr< gravity_type > x)
{
  this->gravity_.set (std::move (x));
}

const forces::lennard_jones_optional& forces::
lennard_jones () const
{
  return this->lennard_jones_;
}

forces::lennard_jones_optional& forces::
lennard_jones ()
{
  return this->lennard_jones_;
}

void forces::
lennard_jones (const lennard_jones_type& x)
{
  this->lennard_jones_.set (x);
}

void forces::
lennard_jones (const lennard_jones_optional& x)
{
  this->lennard_jones_ = x;
}

void forces::
lennard_jones (::std::unique_ptr< lennard_jones_type > x)
{
  this->lennard_jones_.set (std::move (x));
}


// linked_cells
//

const linked_cells::domain_size_type& linked_cells::
domain_size () const
{
  return this->domain_size_.get ();
}

linked_cells::domain_size_type& linked_cells::
domain_size ()
{
  return this->domain_size_.get ();
}

void linked_cells::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void linked_cells::
domain_size (::std::unique_ptr< domain_size_type > x)
{
  this->domain_size_.set (std::move (x));
}

const linked_cells::boundary_conditions_type& linked_cells::
boundary_conditions () const
{
  return this->boundary_conditions_.get ();
}

linked_cells::boundary_conditions_type& linked_cells::
boundary_conditions ()
{
  return this->boundary_conditions_.get ();
}

void linked_cells::
boundary_conditions (const boundary_conditions_type& x)
{
  this->boundary_conditions_.set (x);
}

void linked_cells::
boundary_conditions (::std::unique_ptr< boundary_conditions_type > x)
{
  this->boundary_conditions_.set (std::move (x));
}

const linked_cells::cutoff_radius_type& linked_cells::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

linked_cells::cutoff_radius_type& linked_cells::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void linked_cells::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

void linked_cells::
cutoff_radius (::std::unique_ptr< cutoff_radius_type > x)
{
  this->cutoff_radius_.set (std::move (x));
}


// gravity
//


// lennard_jones
//

const lennard_jones::particleTypes_type& lennard_jones::
particleTypes () const
{
  return this->particleTypes_.get ();
}

lennard_jones::particleTypes_type& lennard_jones::
particleTypes ()
{
  return this->particleTypes_.get ();
}

void lennard_jones::
particleTypes (const particleTypes_type& x)
{
  this->particleTypes_.set (x);
}

void lennard_jones::
particleTypes (::std::unique_ptr< particleTypes_type > x)
{
  this->particleTypes_.set (std::move (x));
}

const lennard_jones::gravity_optional& lennard_jones::
gravity () const
{
  return this->gravity_;
}

lennard_jones::gravity_optional& lennard_jones::
gravity ()
{
  return this->gravity_;
}

void lennard_jones::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void lennard_jones::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

void lennard_jones::
gravity (::std::unique_ptr< gravity_type > x)
{
  this->gravity_.set (std::move (x));
}

const lennard_jones::particles_type& lennard_jones::
particles () const
{
  return this->particles_.get ();
}

lennard_jones::particles_type& lennard_jones::
particles ()
{
  return this->particles_.get ();
}

void lennard_jones::
particles (const particles_type& x)
{
  this->particles_.set (x);
}

void lennard_jones::
particles (::std::unique_ptr< particles_type > x)
{
  this->particles_.set (std::move (x));
}


// domain_size
//

const domain_size::x_type& domain_size::
x () const
{
  return this->x_.get ();
}

domain_size::x_type& domain_size::
x ()
{
  return this->x_.get ();
}

void domain_size::
x (const x_type& x)
{
  this->x_.set (x);
}

const domain_size::y_type& domain_size::
y () const
{
  return this->y_.get ();
}

domain_size::y_type& domain_size::
y ()
{
  return this->y_.get ();
}

void domain_size::
y (const y_type& x)
{
  this->y_.set (x);
}

const domain_size::z_optional& domain_size::
z () const
{
  return this->z_;
}

domain_size::z_optional& domain_size::
z ()
{
  return this->z_;
}

void domain_size::
z (const z_type& x)
{
  this->z_.set (x);
}

void domain_size::
z (const z_optional& x)
{
  this->z_ = x;
}


// boundary_conditions
//

const boundary_conditions::boundary_condition_sequence& boundary_conditions::
boundary_condition () const
{
  return this->boundary_condition_;
}

boundary_conditions::boundary_condition_sequence& boundary_conditions::
boundary_condition ()
{
  return this->boundary_condition_;
}

void boundary_conditions::
boundary_condition (const boundary_condition_sequence& s)
{
  this->boundary_condition_ = s;
}


// particleTypes
//

const particleTypes::particleType_sequence& particleTypes::
particleType () const
{
  return this->particleType_;
}

particleTypes::particleType_sequence& particleTypes::
particleType ()
{
  return this->particleType_;
}

void particleTypes::
particleType (const particleType_sequence& s)
{
  this->particleType_ = s;
}


// gravity1
//

const gravity1::x_type& gravity1::
x () const
{
  return this->x_.get ();
}

gravity1::x_type& gravity1::
x ()
{
  return this->x_.get ();
}

void gravity1::
x (const x_type& x)
{
  this->x_.set (x);
}

const gravity1::y_type& gravity1::
y () const
{
  return this->y_.get ();
}

gravity1::y_type& gravity1::
y ()
{
  return this->y_.get ();
}

void gravity1::
y (const y_type& x)
{
  this->y_.set (x);
}

const gravity1::z_optional& gravity1::
z () const
{
  return this->z_;
}

gravity1::z_optional& gravity1::
z ()
{
  return this->z_;
}

void gravity1::
z (const z_type& x)
{
  this->z_.set (x);
}

void gravity1::
z (const z_optional& x)
{
  this->z_ = x;
}


// particles
//

const particles::cuboid_sequence& particles::
cuboid () const
{
  return this->cuboid_;
}

particles::cuboid_sequence& particles::
cuboid ()
{
  return this->cuboid_;
}

void particles::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}

const particles::disc_sequence& particles::
disc () const
{
  return this->disc_;
}

particles::disc_sequence& particles::
disc ()
{
  return this->disc_;
}

void particles::
disc (const disc_sequence& s)
{
  this->disc_ = s;
}

const particles::sphere_sequence& particles::
sphere () const
{
  return this->sphere_;
}

particles::sphere_sequence& particles::
sphere ()
{
  return this->sphere_;
}

void particles::
sphere (const sphere_sequence& s)
{
  this->sphere_ = s;
}

const particles::torus_sequence& particles::
torus () const
{
  return this->torus_;
}

particles::torus_sequence& particles::
torus ()
{
  return this->torus_;
}

void particles::
torus (const torus_sequence& s)
{
  this->torus_ = s;
}

const particles::doubleHelix_sequence& particles::
doubleHelix () const
{
  return this->doubleHelix_;
}

particles::doubleHelix_sequence& particles::
doubleHelix ()
{
  return this->doubleHelix_;
}

void particles::
doubleHelix (const doubleHelix_sequence& s)
{
  this->doubleHelix_ = s;
}


// boundary_condition
//

const boundary_condition::type_type& boundary_condition::
type () const
{
  return this->type_.get ();
}

boundary_condition::type_type& boundary_condition::
type ()
{
  return this->type_.get ();
}

void boundary_condition::
type (const type_type& x)
{
  this->type_.set (x);
}

void boundary_condition::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


// particleType
//

const particleType::id_type& particleType::
id () const
{
  return this->id_.get ();
}

particleType::id_type& particleType::
id ()
{
  return this->id_.get ();
}

void particleType::
id (const id_type& x)
{
  this->id_.set (x);
}

const particleType::sigma_type& particleType::
sigma () const
{
  return this->sigma_.get ();
}

particleType::sigma_type& particleType::
sigma ()
{
  return this->sigma_.get ();
}

void particleType::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const particleType::epsilon_type& particleType::
epsilon () const
{
  return this->epsilon_.get ();
}

particleType::epsilon_type& particleType::
epsilon ()
{
  return this->epsilon_.get ();
}

void particleType::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const particleType::mass_type& particleType::
mass () const
{
  return this->mass_.get ();
}

particleType::mass_type& particleType::
mass ()
{
  return this->mass_.get ();
}

void particleType::
mass (const mass_type& x)
{
  this->mass_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// celestial_body
//

celestial_body::
celestial_body (const coordinate_type& coordinate,
                const velocity_type& velocity,
                const mass_type& mass)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  mass_ (mass, this)
{
}

celestial_body::
celestial_body (::std::unique_ptr< coordinate_type > coordinate,
                ::std::unique_ptr< velocity_type > velocity,
                const mass_type& mass)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  mass_ (mass, this)
{
}

celestial_body::
celestial_body (const celestial_body& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this)
{
}

celestial_body::
celestial_body (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void celestial_body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!mass_.present ())
      {
        this->mass_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

celestial_body* celestial_body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class celestial_body (*this, f, c);
}

celestial_body& celestial_body::
operator= (const celestial_body& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
  }

  return *this;
}

celestial_body::
~celestial_body ()
{
}

// cuboid
//

cuboid::
cuboid (const coordinate_type& coordinate,
        const dimensions_type& dimensions,
        const velocity_type& velocity,
        const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  dimensions_ (dimensions, this),
  velocity_ (velocity, this),
  particleTypeId_ (particleTypeId, this),
  spacing_ (this)
{
}

cuboid::
cuboid (::std::unique_ptr< coordinate_type > coordinate,
        ::std::unique_ptr< dimensions_type > dimensions,
        ::std::unique_ptr< velocity_type > velocity,
        const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  dimensions_ (std::move (dimensions), this),
  velocity_ (std::move (velocity), this),
  particleTypeId_ (particleTypeId, this),
  spacing_ (this)
{
}

cuboid::
cuboid (const cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  dimensions_ (x.dimensions_, f, this),
  velocity_ (x.velocity_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this),
  spacing_ (x.spacing_, f, this)
{
}

cuboid::
cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  dimensions_ (this),
  velocity_ (this),
  particleTypeId_ (this),
  spacing_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dimensions_type > r (
        dimensions_traits::create (i, f, this));

      if (!dimensions_.present ())
      {
        this->dimensions_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensions",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "spacing" && n.namespace_ ().empty ())
    {
      this->spacing_.set (spacing_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

cuboid* cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid (*this, f, c);
}

cuboid& cuboid::
operator= (const cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->dimensions_ = x.dimensions_;
    this->velocity_ = x.velocity_;
    this->particleTypeId_ = x.particleTypeId_;
    this->spacing_ = x.spacing_;
  }

  return *this;
}

cuboid::
~cuboid ()
{
}

// disc
//

disc::
disc (const coordinate_type& coordinate,
      const velocity_type& velocity,
      const radius_type& radius,
      const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

disc::
disc (::std::unique_ptr< coordinate_type > coordinate,
      ::std::unique_ptr< velocity_type > velocity,
      const radius_type& radius,
      const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

disc::
disc (const disc& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this)
{
}

disc::
disc (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this),
  particleTypeId_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void disc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

disc* disc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class disc (*this, f, c);
}

disc& disc::
operator= (const disc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
    this->particleTypeId_ = x.particleTypeId_;
  }

  return *this;
}

disc::
~disc ()
{
}

// sphere
//

sphere::
sphere (const coordinate_type& coordinate,
        const velocity_type& velocity,
        const radius_type& radius,
        const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

sphere::
sphere (::std::unique_ptr< coordinate_type > coordinate,
        ::std::unique_ptr< velocity_type > velocity,
        const radius_type& radius,
        const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

sphere::
sphere (const sphere& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this)
{
}

sphere::
sphere (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this),
  particleTypeId_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void sphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

sphere* sphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere (*this, f, c);
}

sphere& sphere::
operator= (const sphere& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
    this->particleTypeId_ = x.particleTypeId_;
  }

  return *this;
}

sphere::
~sphere ()
{
}

// torus
//

torus::
torus (const coordinate_type& coordinate,
       const velocity_type& velocity,
       const major_radius_type& major_radius,
       const minor_radius_type& minor_radius,
       const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  major_radius_ (major_radius, this),
  minor_radius_ (minor_radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

torus::
torus (::std::unique_ptr< coordinate_type > coordinate,
       ::std::unique_ptr< velocity_type > velocity,
       const major_radius_type& major_radius,
       const minor_radius_type& minor_radius,
       const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  major_radius_ (major_radius, this),
  minor_radius_ (minor_radius, this),
  particleTypeId_ (particleTypeId, this)
{
}

torus::
torus (const torus& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  major_radius_ (x.major_radius_, f, this),
  minor_radius_ (x.minor_radius_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this)
{
}

torus::
torus (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  major_radius_ (this),
  minor_radius_ (this),
  particleTypeId_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void torus::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // major_radius
    //
    if (n.name () == "major_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< major_radius_type > r (
        major_radius_traits::create (i, f, this));

      if (!major_radius_.present ())
      {
        this->major_radius_.set (::std::move (r));
        continue;
      }
    }

    // minor_radius
    //
    if (n.name () == "minor_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< minor_radius_type > r (
        minor_radius_traits::create (i, f, this));

      if (!minor_radius_.present ())
      {
        this->minor_radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!major_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "major_radius",
      "");
  }

  if (!minor_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minor_radius",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

torus* torus::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class torus (*this, f, c);
}

torus& torus::
operator= (const torus& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->major_radius_ = x.major_radius_;
    this->minor_radius_ = x.minor_radius_;
    this->particleTypeId_ = x.particleTypeId_;
  }

  return *this;
}

torus::
~torus ()
{
}

// double_helix
//

double_helix::
double_helix (const coordinate_type& coordinate,
              const velocity_type& velocity,
              const radius_type& radius,
              const pitch_type& pitch,
              const height_type& height,
              const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this),
  pitch_ (pitch, this),
  height_ (height, this),
  particleTypeId_ (particleTypeId, this)
{
}

double_helix::
double_helix (::std::unique_ptr< coordinate_type > coordinate,
              ::std::unique_ptr< velocity_type > velocity,
              const radius_type& radius,
              const pitch_type& pitch,
              const height_type& height,
              const particleTypeId_type& particleTypeId)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this),
  pitch_ (pitch, this),
  height_ (height, this),
  particleTypeId_ (particleTypeId, this)
{
}

double_helix::
double_helix (const double_helix& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this),
  pitch_ (x.pitch_, f, this),
  height_ (x.height_, f, this),
  particleTypeId_ (x.particleTypeId_, f, this)
{
}

double_helix::
double_helix (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this),
  pitch_ (this),
  height_ (this),
  particleTypeId_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void double_helix::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    // pitch
    //
    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< pitch_type > r (
        pitch_traits::create (i, f, this));

      if (!pitch_.present ())
      {
        this->pitch_.set (::std::move (r));
        continue;
      }
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< height_type > r (
        height_traits::create (i, f, this));

      if (!height_.present ())
      {
        this->height_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!pitch_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pitch",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "height",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "particleTypeId" && n.namespace_ ().empty ())
    {
      this->particleTypeId_.set (particleTypeId_traits::create (i, f, this));
      continue;
    }
  }

  if (!particleTypeId_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "particleTypeId",
      "");
  }
}

double_helix* double_helix::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class double_helix (*this, f, c);
}

double_helix& double_helix::
operator= (const double_helix& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
    this->pitch_ = x.pitch_;
    this->height_ = x.height_;
    this->particleTypeId_ = x.particleTypeId_;
  }

  return *this;
}

double_helix::
~double_helix ()
{
}

// coordinate
//

coordinate::
coordinate (const x_type& x,
            const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

coordinate::
coordinate (const coordinate& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

coordinate::
coordinate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void coordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

coordinate* coordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class coordinate (*this, f, c);
}

coordinate& coordinate::
operator= (const coordinate& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

coordinate::
~coordinate ()
{
}

// velocity
//

velocity::
velocity (const x_type& x,
          const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

velocity::
velocity (const velocity& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

velocity::
velocity (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void velocity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

velocity* velocity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class velocity (*this, f, c);
}

velocity& velocity::
operator= (const velocity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

velocity::
~velocity ()
{
}

// dimensions
//

dimensions::
dimensions (const x_type& x,
            const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

dimensions::
dimensions (const dimensions& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

dimensions::
dimensions (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void dimensions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

dimensions* dimensions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dimensions (*this, f, c);
}

dimensions& dimensions::
operator= (const dimensions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

dimensions::
~dimensions ()
{
}

// positive_int
//

positive_int::
positive_int (const ::xml_schema::int_& _xsd_int__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (_xsd_int__base)
{
}

positive_int::
positive_int (const positive_int& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
{
}

positive_int::
positive_int (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
{
}

positive_int::
positive_int (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
{
}

positive_int::
positive_int (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

positive_int* positive_int::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positive_int (*this, f, c);
}

positive_int::
~positive_int ()
{
}

// positive_double
//

positive_double::
positive_double (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

positive_double::
positive_double (const positive_double& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

positive_double::
positive_double (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

positive_double::
positive_double (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

positive_double::
positive_double (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

positive_double* positive_double::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positive_double (*this, f, c);
}

positive_double::
~positive_double ()
{
}

// scenario
//

scenario::
scenario (const header_type& header,
          const container_type& container,
          const forces_type& forces)
: ::xml_schema::type (),
  header_ (header, this),
  thermostat_ (this),
  container_ (container, this),
  forces_ (forces, this)
{
}

scenario::
scenario (::std::unique_ptr< header_type > header,
          ::std::unique_ptr< container_type > container,
          ::std::unique_ptr< forces_type > forces)
: ::xml_schema::type (),
  header_ (std::move (header), this),
  thermostat_ (this),
  container_ (std::move (container), this),
  forces_ (std::move (forces), this)
{
}

scenario::
scenario (const scenario& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  header_ (x.header_, f, this),
  thermostat_ (x.thermostat_, f, this),
  container_ (x.container_, f, this),
  forces_ (x.forces_, f, this)
{
}

scenario::
scenario (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  header_ (this),
  thermostat_ (this),
  container_ (this),
  forces_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void scenario::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< header_type > r (
        header_traits::create (i, f, this));

      if (!header_.present ())
      {
        this->header_.set (::std::move (r));
        continue;
      }
    }

    // thermostat
    //
    if (n.name () == "thermostat" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< thermostat_type > r (
        thermostat_traits::create (i, f, this));

      if (!this->thermostat_)
      {
        this->thermostat_.set (::std::move (r));
        continue;
      }
    }

    // container
    //
    if (n.name () == "container" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< container_type > r (
        container_traits::create (i, f, this));

      if (!container_.present ())
      {
        this->container_.set (::std::move (r));
        continue;
      }
    }

    // forces
    //
    if (n.name () == "forces" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< forces_type > r (
        forces_traits::create (i, f, this));

      if (!forces_.present ())
      {
        this->forces_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!header_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "header",
      "");
  }

  if (!container_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "container",
      "");
  }

  if (!forces_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "forces",
      "");
  }
}

scenario* scenario::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class scenario (*this, f, c);
}

scenario& scenario::
operator= (const scenario& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->header_ = x.header_;
    this->thermostat_ = x.thermostat_;
    this->container_ = x.container_;
    this->forces_ = x.forces_;
  }

  return *this;
}

scenario::
~scenario ()
{
}

// header
//

header::
header (const base_name_type& base_name,
        const t_end_type& t_end,
        const delta_t_type& delta_t,
        const output_frequency_type& output_frequency,
        const output_file_type& output_file,
        const seed_type& seed)
: ::xml_schema::type (),
  base_name_ (base_name, this),
  t_start_ (this),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  output_frequency_ (output_frequency, this),
  output_file_ (output_file, this),
  seed_ (seed, this)
{
}

header::
header (const header& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  base_name_ (x.base_name_, f, this),
  t_start_ (x.t_start_, f, this),
  t_end_ (x.t_end_, f, this),
  delta_t_ (x.delta_t_, f, this),
  output_frequency_ (x.output_frequency_, f, this),
  output_file_ (x.output_file_, f, this),
  seed_ (x.seed_, f, this)
{
}

header::
header (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  base_name_ (this),
  t_start_ (this),
  t_end_ (this),
  delta_t_ (this),
  output_frequency_ (this),
  output_file_ (this),
  seed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "base_name" && n.namespace_ ().empty ())
    {
      this->base_name_.set (base_name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t_start" && n.namespace_ ().empty ())
    {
      this->t_start_.set (t_start_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      this->t_end_.set (t_end_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      this->delta_t_.set (delta_t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_frequency" && n.namespace_ ().empty ())
    {
      this->output_frequency_.set (output_frequency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_file" && n.namespace_ ().empty ())
    {
      this->output_file_.set (output_file_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "seed" && n.namespace_ ().empty ())
    {
      this->seed_.set (seed_traits::create (i, f, this));
      continue;
    }
  }

  if (!base_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "base_name",
      "");
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t_end",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "delta_t",
      "");
  }

  if (!output_frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_frequency",
      "");
  }

  if (!output_file_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_file",
      "");
  }

  if (!seed_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "seed",
      "");
  }
}

header* header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class header (*this, f, c);
}

header& header::
operator= (const header& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->base_name_ = x.base_name_;
    this->t_start_ = x.t_start_;
    this->t_end_ = x.t_end_;
    this->delta_t_ = x.delta_t_;
    this->output_frequency_ = x.output_frequency_;
    this->output_file_ = x.output_file_;
    this->seed_ = x.seed_;
  }

  return *this;
}

header::
~header ()
{
}

// thermostat
//

thermostat::
thermostat (const t_init_type& t_init,
            const frequency_type& frequency)
: ::xml_schema::type (),
  t_init_ (t_init, this),
  t_target_ (this),
  frequency_ (frequency, this),
  max_temp_diff_ (this),
  brownian_motion_ (this)
{
}

thermostat::
thermostat (const thermostat& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  t_init_ (x.t_init_, f, this),
  t_target_ (x.t_target_, f, this),
  frequency_ (x.frequency_, f, this),
  max_temp_diff_ (x.max_temp_diff_, f, this),
  brownian_motion_ (x.brownian_motion_, f, this)
{
}

thermostat::
thermostat (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  t_init_ (this),
  t_target_ (this),
  frequency_ (this),
  max_temp_diff_ (this),
  brownian_motion_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void thermostat::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "t_init" && n.namespace_ ().empty ())
    {
      this->t_init_.set (t_init_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t_target" && n.namespace_ ().empty ())
    {
      this->t_target_.set (t_target_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "frequency" && n.namespace_ ().empty ())
    {
      this->frequency_.set (frequency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "max_temp_diff" && n.namespace_ ().empty ())
    {
      this->max_temp_diff_.set (max_temp_diff_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "brownian_motion" && n.namespace_ ().empty ())
    {
      this->brownian_motion_.set (brownian_motion_traits::create (i, f, this));
      continue;
    }
  }

  if (!t_init_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t_init",
      "");
  }

  if (!frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "frequency",
      "");
  }
}

thermostat* thermostat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class thermostat (*this, f, c);
}

thermostat& thermostat::
operator= (const thermostat& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->t_init_ = x.t_init_;
    this->t_target_ = x.t_target_;
    this->frequency_ = x.frequency_;
    this->max_temp_diff_ = x.max_temp_diff_;
    this->brownian_motion_ = x.brownian_motion_;
  }

  return *this;
}

thermostat::
~thermostat ()
{
}

// container
//

const container::vector_type container::vector_default_value_ (
  "");

container::
container ()
: ::xml_schema::type (),
  linked_cells_ (this),
  vector_ (this)
{
}

container::
container (const container& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  linked_cells_ (x.linked_cells_, f, this),
  vector_ (x.vector_, f, this)
{
}

container::
container (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  linked_cells_ (this),
  vector_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void container::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // linked_cells
    //
    if (n.name () == "linked_cells" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< linked_cells_type > r (
        linked_cells_traits::create (i, f, this));

      if (!this->linked_cells_)
      {
        this->linked_cells_.set (::std::move (r));
        continue;
      }
    }

    // vector
    //
    if (n.name () == "vector" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< vector_type > r (
        vector_traits::create (i, f, this));

      if (!this->vector_)
      {
        this->vector_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

container* container::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class container (*this, f, c);
}

container& container::
operator= (const container& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->linked_cells_ = x.linked_cells_;
    this->vector_ = x.vector_;
  }

  return *this;
}

container::
~container ()
{
}

// forces
//

forces::
forces ()
: ::xml_schema::type (),
  gravity_ (this),
  lennard_jones_ (this)
{
}

forces::
forces (const forces& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  gravity_ (x.gravity_, f, this),
  lennard_jones_ (x.lennard_jones_, f, this)
{
}

forces::
forces (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  gravity_ (this),
  lennard_jones_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void forces::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravity_type > r (
        gravity_traits::create (i, f, this));

      if (!this->gravity_)
      {
        this->gravity_.set (::std::move (r));
        continue;
      }
    }

    // lennard_jones
    //
    if (n.name () == "lennard_jones" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lennard_jones_type > r (
        lennard_jones_traits::create (i, f, this));

      if (!this->lennard_jones_)
      {
        this->lennard_jones_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

forces* forces::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class forces (*this, f, c);
}

forces& forces::
operator= (const forces& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->gravity_ = x.gravity_;
    this->lennard_jones_ = x.lennard_jones_;
  }

  return *this;
}

forces::
~forces ()
{
}

// linked_cells
//

linked_cells::
linked_cells (const domain_size_type& domain_size,
              const boundary_conditions_type& boundary_conditions,
              const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  domain_size_ (domain_size, this),
  boundary_conditions_ (boundary_conditions, this),
  cutoff_radius_ (cutoff_radius, this)
{
}

linked_cells::
linked_cells (::std::unique_ptr< domain_size_type > domain_size,
              ::std::unique_ptr< boundary_conditions_type > boundary_conditions,
              const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  domain_size_ (std::move (domain_size), this),
  boundary_conditions_ (std::move (boundary_conditions), this),
  cutoff_radius_ (cutoff_radius, this)
{
}

linked_cells::
linked_cells (const linked_cells& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  domain_size_ (x.domain_size_, f, this),
  boundary_conditions_ (x.boundary_conditions_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this)
{
}

linked_cells::
linked_cells (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  domain_size_ (this),
  boundary_conditions_ (this),
  cutoff_radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void linked_cells::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (::std::move (r));
        continue;
      }
    }

    // boundary_conditions
    //
    if (n.name () == "boundary_conditions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_conditions_type > r (
        boundary_conditions_traits::create (i, f, this));

      if (!boundary_conditions_.present ())
      {
        this->boundary_conditions_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain_size",
      "");
  }

  if (!boundary_conditions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary_conditions",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      this->cutoff_radius_.set (cutoff_radius_traits::create (i, f, this));
      continue;
    }
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cutoff_radius",
      "");
  }
}

linked_cells* linked_cells::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class linked_cells (*this, f, c);
}

linked_cells& linked_cells::
operator= (const linked_cells& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->domain_size_ = x.domain_size_;
    this->boundary_conditions_ = x.boundary_conditions_;
    this->cutoff_radius_ = x.cutoff_radius_;
  }

  return *this;
}

linked_cells::
~linked_cells ()
{
}

// gravity
//

gravity::
gravity ()
: ::xml_schema::type ()
{
}

gravity::
gravity (const gravity& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

gravity::
gravity (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

gravity::
gravity (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

gravity::
gravity (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

gravity* gravity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravity (*this, f, c);
}

gravity::
~gravity ()
{
}

// lennard_jones
//

lennard_jones::
lennard_jones (const particleTypes_type& particleTypes,
               const particles_type& particles)
: ::xml_schema::type (),
  particleTypes_ (particleTypes, this),
  gravity_ (this),
  particles_ (particles, this)
{
}

lennard_jones::
lennard_jones (::std::unique_ptr< particleTypes_type > particleTypes,
               ::std::unique_ptr< particles_type > particles)
: ::xml_schema::type (),
  particleTypes_ (std::move (particleTypes), this),
  gravity_ (this),
  particles_ (std::move (particles), this)
{
}

lennard_jones::
lennard_jones (const lennard_jones& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particleTypes_ (x.particleTypes_, f, this),
  gravity_ (x.gravity_, f, this),
  particles_ (x.particles_, f, this)
{
}

lennard_jones::
lennard_jones (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particleTypes_ (this),
  gravity_ (this),
  particles_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lennard_jones::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particleTypes
    //
    if (n.name () == "particleTypes" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particleTypes_type > r (
        particleTypes_traits::create (i, f, this));

      if (!particleTypes_.present ())
      {
        this->particleTypes_.set (::std::move (r));
        continue;
      }
    }

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravity_type > r (
        gravity_traits::create (i, f, this));

      if (!this->gravity_)
      {
        this->gravity_.set (::std::move (r));
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      if (!particles_.present ())
      {
        this->particles_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!particleTypes_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particleTypes",
      "");
  }

  if (!particles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particles",
      "");
  }
}

lennard_jones* lennard_jones::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lennard_jones (*this, f, c);
}

lennard_jones& lennard_jones::
operator= (const lennard_jones& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particleTypes_ = x.particleTypes_;
    this->gravity_ = x.gravity_;
    this->particles_ = x.particles_;
  }

  return *this;
}

lennard_jones::
~lennard_jones ()
{
}

// domain_size
//

domain_size::
domain_size (const x_type& x,
             const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

domain_size::
domain_size (const domain_size& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

domain_size::
domain_size (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void domain_size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

domain_size* domain_size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class domain_size (*this, f, c);
}

domain_size& domain_size::
operator= (const domain_size& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

domain_size::
~domain_size ()
{
}

// boundary_conditions
//

boundary_conditions::
boundary_conditions ()
: ::xml_schema::type (),
  boundary_condition_ (this)
{
}

boundary_conditions::
boundary_conditions (const boundary_conditions& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  boundary_condition_ (x.boundary_condition_, f, this)
{
}

boundary_conditions::
boundary_conditions (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  boundary_condition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundary_conditions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // boundary_condition
    //
    if (n.name () == "boundary_condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_condition_type > r (
        boundary_condition_traits::create (i, f, this));

      this->boundary_condition_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

boundary_conditions* boundary_conditions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_conditions (*this, f, c);
}

boundary_conditions& boundary_conditions::
operator= (const boundary_conditions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->boundary_condition_ = x.boundary_condition_;
  }

  return *this;
}

boundary_conditions::
~boundary_conditions ()
{
}

// particleTypes
//

particleTypes::
particleTypes ()
: ::xml_schema::type (),
  particleType_ (this)
{
}

particleTypes::
particleTypes (const particleTypes& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particleType_ (x.particleType_, f, this)
{
}

particleTypes::
particleTypes (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particleType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particleTypes::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particleType
    //
    if (n.name () == "particleType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particleType_type > r (
        particleType_traits::create (i, f, this));

      this->particleType_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

particleTypes* particleTypes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particleTypes (*this, f, c);
}

particleTypes& particleTypes::
operator= (const particleTypes& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particleType_ = x.particleType_;
  }

  return *this;
}

particleTypes::
~particleTypes ()
{
}

// gravity1
//

gravity1::
gravity1 (const x_type& x,
          const y_type& y)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (this)
{
}

gravity1::
gravity1 (const gravity1& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

gravity1::
gravity1 (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void gravity1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }
}

gravity1* gravity1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravity1 (*this, f, c);
}

gravity1& gravity1::
operator= (const gravity1& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

gravity1::
~gravity1 ()
{
}

// particles
//

particles::
particles ()
: ::xml_schema::type (),
  cuboid_ (this),
  disc_ (this),
  sphere_ (this),
  torus_ (this),
  doubleHelix_ (this)
{
}

particles::
particles (const particles& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cuboid_ (x.cuboid_, f, this),
  disc_ (x.disc_, f, this),
  sphere_ (x.sphere_, f, this),
  torus_ (x.torus_, f, this),
  doubleHelix_ (x.doubleHelix_, f, this)
{
}

particles::
particles (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cuboid_ (this),
  disc_ (this),
  sphere_ (this),
  torus_ (this),
  doubleHelix_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (::std::move (r));
      continue;
    }

    // disc
    //
    if (n.name () == "disc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< disc_type > r (
        disc_traits::create (i, f, this));

      this->disc_.push_back (::std::move (r));
      continue;
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      this->sphere_.push_back (::std::move (r));
      continue;
    }

    // torus
    //
    if (n.name () == "torus" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< torus_type > r (
        torus_traits::create (i, f, this));

      this->torus_.push_back (::std::move (r));
      continue;
    }

    // doubleHelix
    //
    if (n.name () == "doubleHelix" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< doubleHelix_type > r (
        doubleHelix_traits::create (i, f, this));

      this->doubleHelix_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

particles* particles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particles (*this, f, c);
}

particles& particles::
operator= (const particles& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cuboid_ = x.cuboid_;
    this->disc_ = x.disc_;
    this->sphere_ = x.sphere_;
    this->torus_ = x.torus_;
    this->doubleHelix_ = x.doubleHelix_;
  }

  return *this;
}

particles::
~particles ()
{
}

// boundary_condition
//

boundary_condition::
boundary_condition (const type_type& type)
: ::xml_schema::type (),
  type_ (type, this)
{
}

boundary_condition::
boundary_condition (const boundary_condition& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this)
{
}

boundary_condition::
boundary_condition (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void boundary_condition::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

boundary_condition* boundary_condition::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_condition (*this, f, c);
}

boundary_condition& boundary_condition::
operator= (const boundary_condition& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

boundary_condition::
~boundary_condition ()
{
}

// particleType
//

particleType::
particleType (const id_type& id,
              const sigma_type& sigma,
              const epsilon_type& epsilon,
              const mass_type& mass)
: ::xml_schema::type (),
  id_ (id, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this),
  mass_ (mass, this)
{
}

particleType::
particleType (const particleType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  id_ (x.id_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this),
  mass_ (x.mass_, f, this)
{
}

particleType::
particleType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  id_ (this),
  sigma_ (this),
  epsilon_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void particleType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (sigma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (epsilon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (mass_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "epsilon",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mass",
      "");
  }
}

particleType* particleType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particleType (*this, f, c);
}

particleType& particleType::
operator= (const particleType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->id_ = x.id_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
    this->mass_ = x.mass_;
  }

  return *this;
}

particleType::
~particleType ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::scenario >
scenario_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scenario_ (isrc, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scenario_ (isrc, h, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::scenario_ (isrc, h, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scenario_ (isrc, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scenario_ (isrc, h, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::scenario_ (isrc, h, f, p);
}

::std::unique_ptr< ::scenario >
scenario_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::scenario > (
    ::scenario_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::scenario >
scenario_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::scenario > (
      ::scenario_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "scenario" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::scenario > r (
      ::xsd::cxx::tree::traits< ::scenario, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "scenario",
    "");
}

::std::unique_ptr< ::scenario >
scenario_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "scenario" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::scenario > r (
      ::xsd::cxx::tree::traits< ::scenario, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "scenario",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

