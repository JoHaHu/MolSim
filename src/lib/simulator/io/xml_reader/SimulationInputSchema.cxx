// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SimulationInputSchema.hxx"

// celestial_body
//

const celestial_body::coordinate_type& celestial_body::
coordinate () const
{
  return this->coordinate_.get ();
}

celestial_body::coordinate_type& celestial_body::
coordinate ()
{
  return this->coordinate_.get ();
}

void celestial_body::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void celestial_body::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const celestial_body::velocity_type& celestial_body::
velocity () const
{
  return this->velocity_.get ();
}

celestial_body::velocity_type& celestial_body::
velocity ()
{
  return this->velocity_.get ();
}

void celestial_body::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void celestial_body::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const celestial_body::mass_type& celestial_body::
mass () const
{
  return this->mass_.get ();
}

celestial_body::mass_type& celestial_body::
mass ()
{
  return this->mass_.get ();
}

void celestial_body::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void celestial_body::
mass (::std::unique_ptr< mass_type > x)
{
  this->mass_.set (std::move (x));
}


// cuboid
//

const cuboid::coordinate_type& cuboid::
coordinate () const
{
  return this->coordinate_.get ();
}

cuboid::coordinate_type& cuboid::
coordinate ()
{
  return this->coordinate_.get ();
}

void cuboid::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void cuboid::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const cuboid::particle_counts_type& cuboid::
particle_counts () const
{
  return this->particle_counts_.get ();
}

cuboid::particle_counts_type& cuboid::
particle_counts ()
{
  return this->particle_counts_.get ();
}

void cuboid::
particle_counts (const particle_counts_type& x)
{
  this->particle_counts_.set (x);
}

void cuboid::
particle_counts (::std::unique_ptr< particle_counts_type > x)
{
  this->particle_counts_.set (std::move (x));
}

const cuboid::velocity_type& cuboid::
velocity () const
{
  return this->velocity_.get ();
}

cuboid::velocity_type& cuboid::
velocity ()
{
  return this->velocity_.get ();
}

void cuboid::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboid::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}


// disc
//

const disc::coordinate_type& disc::
coordinate () const
{
  return this->coordinate_.get ();
}

disc::coordinate_type& disc::
coordinate ()
{
  return this->coordinate_.get ();
}

void disc::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void disc::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const disc::velocity_type& disc::
velocity () const
{
  return this->velocity_.get ();
}

disc::velocity_type& disc::
velocity ()
{
  return this->velocity_.get ();
}

void disc::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void disc::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const disc::radius_type& disc::
radius () const
{
  return this->radius_.get ();
}

disc::radius_type& disc::
radius ()
{
  return this->radius_.get ();
}

void disc::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void disc::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}


// sphere
//

const sphere::coordinate_type& sphere::
coordinate () const
{
  return this->coordinate_.get ();
}

sphere::coordinate_type& sphere::
coordinate ()
{
  return this->coordinate_.get ();
}

void sphere::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void sphere::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const sphere::velocity_type& sphere::
velocity () const
{
  return this->velocity_.get ();
}

sphere::velocity_type& sphere::
velocity ()
{
  return this->velocity_.get ();
}

void sphere::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void sphere::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const sphere::radius_type& sphere::
radius () const
{
  return this->radius_.get ();
}

sphere::radius_type& sphere::
radius ()
{
  return this->radius_.get ();
}

void sphere::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void sphere::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}


// torus
//

const torus::coordinate_type& torus::
coordinate () const
{
  return this->coordinate_.get ();
}

torus::coordinate_type& torus::
coordinate ()
{
  return this->coordinate_.get ();
}

void torus::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void torus::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const torus::velocity_type& torus::
velocity () const
{
  return this->velocity_.get ();
}

torus::velocity_type& torus::
velocity ()
{
  return this->velocity_.get ();
}

void torus::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void torus::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const torus::major_radius_type& torus::
major_radius () const
{
  return this->major_radius_.get ();
}

torus::major_radius_type& torus::
major_radius ()
{
  return this->major_radius_.get ();
}

void torus::
major_radius (const major_radius_type& x)
{
  this->major_radius_.set (x);
}

void torus::
major_radius (::std::unique_ptr< major_radius_type > x)
{
  this->major_radius_.set (std::move (x));
}

const torus::minor_radius_type& torus::
minor_radius () const
{
  return this->minor_radius_.get ();
}

torus::minor_radius_type& torus::
minor_radius ()
{
  return this->minor_radius_.get ();
}

void torus::
minor_radius (const minor_radius_type& x)
{
  this->minor_radius_.set (x);
}

void torus::
minor_radius (::std::unique_ptr< minor_radius_type > x)
{
  this->minor_radius_.set (std::move (x));
}


// double_helix
//

const double_helix::coordinate_type& double_helix::
coordinate () const
{
  return this->coordinate_.get ();
}

double_helix::coordinate_type& double_helix::
coordinate ()
{
  return this->coordinate_.get ();
}

void double_helix::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void double_helix::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const double_helix::velocity_type& double_helix::
velocity () const
{
  return this->velocity_.get ();
}

double_helix::velocity_type& double_helix::
velocity ()
{
  return this->velocity_.get ();
}

void double_helix::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void double_helix::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const double_helix::radius_type& double_helix::
radius () const
{
  return this->radius_.get ();
}

double_helix::radius_type& double_helix::
radius ()
{
  return this->radius_.get ();
}

void double_helix::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void double_helix::
radius (::std::unique_ptr< radius_type > x)
{
  this->radius_.set (std::move (x));
}

const double_helix::pitch_type& double_helix::
pitch () const
{
  return this->pitch_.get ();
}

double_helix::pitch_type& double_helix::
pitch ()
{
  return this->pitch_.get ();
}

void double_helix::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void double_helix::
pitch (::std::unique_ptr< pitch_type > x)
{
  this->pitch_.set (std::move (x));
}

const double_helix::height_type& double_helix::
height () const
{
  return this->height_.get ();
}

double_helix::height_type& double_helix::
height ()
{
  return this->height_.get ();
}

void double_helix::
height (const height_type& x)
{
  this->height_.set (x);
}

void double_helix::
height (::std::unique_ptr< height_type > x)
{
  this->height_.set (std::move (x));
}


// double_array
//

const double_array::value_sequence& double_array::
value () const
{
  return this->value_;
}

double_array::value_sequence& double_array::
value ()
{
  return this->value_;
}

void double_array::
value (const value_sequence& s)
{
  this->value_ = s;
}


// positive_int
//


// positive_double
//


// Data
//

const Data::header_type& Data::
header () const
{
  return this->header_.get ();
}

Data::header_type& Data::
header ()
{
  return this->header_.get ();
}

void Data::
header (const header_type& x)
{
  this->header_.set (x);
}

void Data::
header (::std::unique_ptr< header_type > x)
{
  this->header_.set (std::move (x));
}

const Data::linked_cells_optional& Data::
linked_cells () const
{
  return this->linked_cells_;
}

Data::linked_cells_optional& Data::
linked_cells ()
{
  return this->linked_cells_;
}

void Data::
linked_cells (const linked_cells_type& x)
{
  this->linked_cells_.set (x);
}

void Data::
linked_cells (const linked_cells_optional& x)
{
  this->linked_cells_ = x;
}

void Data::
linked_cells (::std::unique_ptr< linked_cells_type > x)
{
  this->linked_cells_.set (std::move (x));
}

const Data::vector_optional& Data::
vector () const
{
  return this->vector_;
}

Data::vector_optional& Data::
vector ()
{
  return this->vector_;
}

void Data::
vector (const vector_type& x)
{
  this->vector_.set (x);
}

void Data::
vector (const vector_optional& x)
{
  this->vector_ = x;
}

const Data::gravity_optional& Data::
gravity () const
{
  return this->gravity_;
}

Data::gravity_optional& Data::
gravity ()
{
  return this->gravity_;
}

void Data::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void Data::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

void Data::
gravity (::std::unique_ptr< gravity_type > x)
{
  this->gravity_.set (std::move (x));
}

const Data::lennard_jones_optional& Data::
lennard_jones () const
{
  return this->lennard_jones_;
}

Data::lennard_jones_optional& Data::
lennard_jones ()
{
  return this->lennard_jones_;
}

void Data::
lennard_jones (const lennard_jones_type& x)
{
  this->lennard_jones_.set (x);
}

void Data::
lennard_jones (const lennard_jones_optional& x)
{
  this->lennard_jones_ = x;
}

void Data::
lennard_jones (::std::unique_ptr< lennard_jones_type > x)
{
  this->lennard_jones_.set (std::move (x));
}


// header
//

const header::base_name_type& header::
base_name () const
{
  return this->base_name_.get ();
}

header::base_name_type& header::
base_name ()
{
  return this->base_name_.get ();
}

void header::
base_name (const base_name_type& x)
{
  this->base_name_.set (x);
}

void header::
base_name (::std::unique_ptr< base_name_type > x)
{
  this->base_name_.set (std::move (x));
}

const header::t_end_type& header::
t_end () const
{
  return this->t_end_.get ();
}

header::t_end_type& header::
t_end ()
{
  return this->t_end_.get ();
}

void header::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

void header::
t_end (::std::unique_ptr< t_end_type > x)
{
  this->t_end_.set (std::move (x));
}

const header::output_frequency_type& header::
output_frequency () const
{
  return this->output_frequency_.get ();
}

header::output_frequency_type& header::
output_frequency ()
{
  return this->output_frequency_.get ();
}

void header::
output_frequency (const output_frequency_type& x)
{
  this->output_frequency_.set (x);
}

void header::
output_frequency (::std::unique_ptr< output_frequency_type > x)
{
  this->output_frequency_.set (std::move (x));
}

const header::output_file_name_type& header::
output_file_name () const
{
  return this->output_file_name_.get ();
}

header::output_file_name_type& header::
output_file_name ()
{
  return this->output_file_name_.get ();
}

void header::
output_file_name (const output_file_name_type& x)
{
  this->output_file_name_.set (x);
}

void header::
output_file_name (::std::unique_ptr< output_file_name_type > x)
{
  this->output_file_name_.set (std::move (x));
}

const header::seed_type& header::
seed () const
{
  return this->seed_.get ();
}

header::seed_type& header::
seed ()
{
  return this->seed_.get ();
}

void header::
seed (const seed_type& x)
{
  this->seed_.set (x);
}


// linked_cells
//

const linked_cells::domain_size_type& linked_cells::
domain_size () const
{
  return this->domain_size_.get ();
}

linked_cells::domain_size_type& linked_cells::
domain_size ()
{
  return this->domain_size_.get ();
}

void linked_cells::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void linked_cells::
domain_size (::std::unique_ptr< domain_size_type > x)
{
  this->domain_size_.set (std::move (x));
}

const linked_cells::boundary_conditions_type& linked_cells::
boundary_conditions () const
{
  return this->boundary_conditions_.get ();
}

linked_cells::boundary_conditions_type& linked_cells::
boundary_conditions ()
{
  return this->boundary_conditions_.get ();
}

void linked_cells::
boundary_conditions (const boundary_conditions_type& x)
{
  this->boundary_conditions_.set (x);
}

void linked_cells::
boundary_conditions (::std::unique_ptr< boundary_conditions_type > x)
{
  this->boundary_conditions_.set (std::move (x));
}


// gravity
//

const gravity::total_bodies_type& gravity::
total_bodies () const
{
  return this->total_bodies_.get ();
}

gravity::total_bodies_type& gravity::
total_bodies ()
{
  return this->total_bodies_.get ();
}

void gravity::
total_bodies (const total_bodies_type& x)
{
  this->total_bodies_.set (x);
}

void gravity::
total_bodies (::std::unique_ptr< total_bodies_type > x)
{
  this->total_bodies_.set (std::move (x));
}

const gravity::cutoff_radius_type& gravity::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

gravity::cutoff_radius_type& gravity::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void gravity::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

void gravity::
cutoff_radius (::std::unique_ptr< cutoff_radius_type > x)
{
  this->cutoff_radius_.set (std::move (x));
}

const gravity::celestial_body_sequence& gravity::
celestial_body () const
{
  return this->celestial_body_;
}

gravity::celestial_body_sequence& gravity::
celestial_body ()
{
  return this->celestial_body_;
}

void gravity::
celestial_body (const celestial_body_sequence& s)
{
  this->celestial_body_ = s;
}


// lennard_jones
//

const lennard_jones::settings_type& lennard_jones::
settings () const
{
  return this->settings_.get ();
}

lennard_jones::settings_type& lennard_jones::
settings ()
{
  return this->settings_.get ();
}

void lennard_jones::
settings (const settings_type& x)
{
  this->settings_.set (x);
}

void lennard_jones::
settings (::std::unique_ptr< settings_type > x)
{
  this->settings_.set (std::move (x));
}

const lennard_jones::cuboids_optional& lennard_jones::
cuboids () const
{
  return this->cuboids_;
}

lennard_jones::cuboids_optional& lennard_jones::
cuboids ()
{
  return this->cuboids_;
}

void lennard_jones::
cuboids (const cuboids_type& x)
{
  this->cuboids_.set (x);
}

void lennard_jones::
cuboids (const cuboids_optional& x)
{
  this->cuboids_ = x;
}

void lennard_jones::
cuboids (::std::unique_ptr< cuboids_type > x)
{
  this->cuboids_.set (std::move (x));
}

const lennard_jones::discs_optional& lennard_jones::
discs () const
{
  return this->discs_;
}

lennard_jones::discs_optional& lennard_jones::
discs ()
{
  return this->discs_;
}

void lennard_jones::
discs (const discs_type& x)
{
  this->discs_.set (x);
}

void lennard_jones::
discs (const discs_optional& x)
{
  this->discs_ = x;
}

void lennard_jones::
discs (::std::unique_ptr< discs_type > x)
{
  this->discs_.set (std::move (x));
}

const lennard_jones::spheres_optional& lennard_jones::
spheres () const
{
  return this->spheres_;
}

lennard_jones::spheres_optional& lennard_jones::
spheres ()
{
  return this->spheres_;
}

void lennard_jones::
spheres (const spheres_type& x)
{
  this->spheres_.set (x);
}

void lennard_jones::
spheres (const spheres_optional& x)
{
  this->spheres_ = x;
}

void lennard_jones::
spheres (::std::unique_ptr< spheres_type > x)
{
  this->spheres_.set (std::move (x));
}

const lennard_jones::tori_optional& lennard_jones::
tori () const
{
  return this->tori_;
}

lennard_jones::tori_optional& lennard_jones::
tori ()
{
  return this->tori_;
}

void lennard_jones::
tori (const tori_type& x)
{
  this->tori_.set (x);
}

void lennard_jones::
tori (const tori_optional& x)
{
  this->tori_ = x;
}

void lennard_jones::
tori (::std::unique_ptr< tori_type > x)
{
  this->tori_.set (std::move (x));
}

const lennard_jones::double_helices_optional& lennard_jones::
double_helices () const
{
  return this->double_helices_;
}

lennard_jones::double_helices_optional& lennard_jones::
double_helices ()
{
  return this->double_helices_;
}

void lennard_jones::
double_helices (const double_helices_type& x)
{
  this->double_helices_.set (x);
}

void lennard_jones::
double_helices (const double_helices_optional& x)
{
  this->double_helices_ = x;
}

void lennard_jones::
double_helices (::std::unique_ptr< double_helices_type > x)
{
  this->double_helices_.set (std::move (x));
}


// boundary_conditions
//

const boundary_conditions::boundary_condition_sequence& boundary_conditions::
boundary_condition () const
{
  return this->boundary_condition_;
}

boundary_conditions::boundary_condition_sequence& boundary_conditions::
boundary_condition ()
{
  return this->boundary_condition_;
}

void boundary_conditions::
boundary_condition (const boundary_condition_sequence& s)
{
  this->boundary_condition_ = s;
}


// settings
//

const settings::delta_t_type& settings::
delta_t () const
{
  return this->delta_t_.get ();
}

settings::delta_t_type& settings::
delta_t ()
{
  return this->delta_t_.get ();
}

void settings::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const settings::sigma_type& settings::
sigma () const
{
  return this->sigma_.get ();
}

settings::sigma_type& settings::
sigma ()
{
  return this->sigma_.get ();
}

void settings::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const settings::epsilon_type& settings::
epsilon () const
{
  return this->epsilon_.get ();
}

settings::epsilon_type& settings::
epsilon ()
{
  return this->epsilon_.get ();
}

void settings::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const settings::mass_m_type& settings::
mass_m () const
{
  return this->mass_m_.get ();
}

settings::mass_m_type& settings::
mass_m ()
{
  return this->mass_m_.get ();
}

void settings::
mass_m (const mass_m_type& x)
{
  this->mass_m_.set (x);
}

const settings::distance_h_type& settings::
distance_h () const
{
  return this->distance_h_.get ();
}

settings::distance_h_type& settings::
distance_h ()
{
  return this->distance_h_.get ();
}

void settings::
distance_h (const distance_h_type& x)
{
  this->distance_h_.set (x);
}

const settings::brown_motion_type& settings::
brown_motion () const
{
  return this->brown_motion_.get ();
}

settings::brown_motion_type& settings::
brown_motion ()
{
  return this->brown_motion_.get ();
}

void settings::
brown_motion (const brown_motion_type& x)
{
  this->brown_motion_.set (x);
}

const settings::cutoff_radius_type& settings::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

settings::cutoff_radius_type& settings::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void settings::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

void settings::
cutoff_radius (::std::unique_ptr< cutoff_radius_type > x)
{
  this->cutoff_radius_.set (std::move (x));
}


// cuboids
//

const cuboids::Cuboid_sequence& cuboids::
Cuboid () const
{
  return this->Cuboid_;
}

cuboids::Cuboid_sequence& cuboids::
Cuboid ()
{
  return this->Cuboid_;
}

void cuboids::
Cuboid (const Cuboid_sequence& s)
{
  this->Cuboid_ = s;
}


// discs
//

const discs::Disc_sequence& discs::
Disc () const
{
  return this->Disc_;
}

discs::Disc_sequence& discs::
Disc ()
{
  return this->Disc_;
}

void discs::
Disc (const Disc_sequence& s)
{
  this->Disc_ = s;
}


// spheres
//

const spheres::Sphere_sequence& spheres::
Sphere () const
{
  return this->Sphere_;
}

spheres::Sphere_sequence& spheres::
Sphere ()
{
  return this->Sphere_;
}

void spheres::
Sphere (const Sphere_sequence& s)
{
  this->Sphere_ = s;
}


// tori
//

const tori::Torus_sequence& tori::
Torus () const
{
  return this->Torus_;
}

tori::Torus_sequence& tori::
Torus ()
{
  return this->Torus_;
}

void tori::
Torus (const Torus_sequence& s)
{
  this->Torus_ = s;
}


// double_helices
//

const double_helices::double_helix_sequence& double_helices::
double_helix () const
{
  return this->double_helix_;
}

double_helices::double_helix_sequence& double_helices::
double_helix ()
{
  return this->double_helix_;
}

void double_helices::
double_helix (const double_helix_sequence& s)
{
  this->double_helix_ = s;
}


// boundary_condition
//

const boundary_condition::type_type& boundary_condition::
type () const
{
  return this->type_.get ();
}

boundary_condition::type_type& boundary_condition::
type ()
{
  return this->type_.get ();
}

void boundary_condition::
type (const type_type& x)
{
  this->type_.set (x);
}

void boundary_condition::
type (::std::unique_ptr< type_type > x)
{
  this->type_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// celestial_body
//

celestial_body::
celestial_body (const coordinate_type& coordinate,
                const velocity_type& velocity,
                const mass_type& mass)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  mass_ (mass, this)
{
}

celestial_body::
celestial_body (::std::unique_ptr< coordinate_type > coordinate,
                ::std::unique_ptr< velocity_type > velocity,
                const mass_type& mass)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  mass_ (mass, this)
{
}

celestial_body::
celestial_body (const celestial_body& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this)
{
}

celestial_body::
celestial_body (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void celestial_body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      if (!mass_.present ())
      {
        this->mass_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

celestial_body* celestial_body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class celestial_body (*this, f, c);
}

celestial_body& celestial_body::
operator= (const celestial_body& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
  }

  return *this;
}

celestial_body::
~celestial_body ()
{
}

// cuboid
//

cuboid::
cuboid (const coordinate_type& coordinate,
        const particle_counts_type& particle_counts,
        const velocity_type& velocity)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  particle_counts_ (particle_counts, this),
  velocity_ (velocity, this)
{
}

cuboid::
cuboid (::std::unique_ptr< coordinate_type > coordinate,
        ::std::unique_ptr< particle_counts_type > particle_counts,
        ::std::unique_ptr< velocity_type > velocity)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  particle_counts_ (std::move (particle_counts), this),
  velocity_ (std::move (velocity), this)
{
}

cuboid::
cuboid (const cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  particle_counts_ (x.particle_counts_, f, this),
  velocity_ (x.velocity_, f, this)
{
}

cuboid::
cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  particle_counts_ (this),
  velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // particle_counts
    //
    if (n.name () == "particle_counts" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particle_counts_type > r (
        particle_counts_traits::create (i, f, this));

      if (!particle_counts_.present ())
      {
        this->particle_counts_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!particle_counts_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particle_counts",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }
}

cuboid* cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid (*this, f, c);
}

cuboid& cuboid::
operator= (const cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->particle_counts_ = x.particle_counts_;
    this->velocity_ = x.velocity_;
  }

  return *this;
}

cuboid::
~cuboid ()
{
}

// disc
//

disc::
disc (const coordinate_type& coordinate,
      const velocity_type& velocity,
      const radius_type& radius)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this)
{
}

disc::
disc (::std::unique_ptr< coordinate_type > coordinate,
      ::std::unique_ptr< velocity_type > velocity,
      const radius_type& radius)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this)
{
}

disc::
disc (const disc& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this)
{
}

disc::
disc (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void disc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }
}

disc* disc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class disc (*this, f, c);
}

disc& disc::
operator= (const disc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
  }

  return *this;
}

disc::
~disc ()
{
}

// sphere
//

sphere::
sphere (const coordinate_type& coordinate,
        const velocity_type& velocity,
        const radius_type& radius)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this)
{
}

sphere::
sphere (::std::unique_ptr< coordinate_type > coordinate,
        ::std::unique_ptr< velocity_type > velocity,
        const radius_type& radius)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this)
{
}

sphere::
sphere (const sphere& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this)
{
}

sphere::
sphere (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void sphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }
}

sphere* sphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere (*this, f, c);
}

sphere& sphere::
operator= (const sphere& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
  }

  return *this;
}

sphere::
~sphere ()
{
}

// torus
//

torus::
torus (const coordinate_type& coordinate,
       const velocity_type& velocity,
       const major_radius_type& major_radius,
       const minor_radius_type& minor_radius)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  major_radius_ (major_radius, this),
  minor_radius_ (minor_radius, this)
{
}

torus::
torus (::std::unique_ptr< coordinate_type > coordinate,
       ::std::unique_ptr< velocity_type > velocity,
       const major_radius_type& major_radius,
       const minor_radius_type& minor_radius)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  major_radius_ (major_radius, this),
  minor_radius_ (minor_radius, this)
{
}

torus::
torus (const torus& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  major_radius_ (x.major_radius_, f, this),
  minor_radius_ (x.minor_radius_, f, this)
{
}

torus::
torus (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  major_radius_ (this),
  minor_radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void torus::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // major_radius
    //
    if (n.name () == "major_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< major_radius_type > r (
        major_radius_traits::create (i, f, this));

      if (!major_radius_.present ())
      {
        this->major_radius_.set (::std::move (r));
        continue;
      }
    }

    // minor_radius
    //
    if (n.name () == "minor_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< minor_radius_type > r (
        minor_radius_traits::create (i, f, this));

      if (!minor_radius_.present ())
      {
        this->minor_radius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!major_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "major_radius",
      "");
  }

  if (!minor_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "minor_radius",
      "");
  }
}

torus* torus::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class torus (*this, f, c);
}

torus& torus::
operator= (const torus& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->major_radius_ = x.major_radius_;
    this->minor_radius_ = x.minor_radius_;
  }

  return *this;
}

torus::
~torus ()
{
}

// double_helix
//

double_helix::
double_helix (const coordinate_type& coordinate,
              const velocity_type& velocity,
              const radius_type& radius,
              const pitch_type& pitch,
              const height_type& height)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this),
  pitch_ (pitch, this),
  height_ (height, this)
{
}

double_helix::
double_helix (::std::unique_ptr< coordinate_type > coordinate,
              ::std::unique_ptr< velocity_type > velocity,
              const radius_type& radius,
              const pitch_type& pitch,
              const height_type& height)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this),
  pitch_ (pitch, this),
  height_ (height, this)
{
}

double_helix::
double_helix (const double_helix& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this),
  pitch_ (x.pitch_, f, this),
  height_ (x.height_, f, this)
{
}

double_helix::
double_helix (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this),
  pitch_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void double_helix::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      if (!radius_.present ())
      {
        this->radius_.set (::std::move (r));
        continue;
      }
    }

    // pitch
    //
    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< pitch_type > r (
        pitch_traits::create (i, f, this));

      if (!pitch_.present ())
      {
        this->pitch_.set (::std::move (r));
        continue;
      }
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< height_type > r (
        height_traits::create (i, f, this));

      if (!height_.present ())
      {
        this->height_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!pitch_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pitch",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "height",
      "");
  }
}

double_helix* double_helix::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class double_helix (*this, f, c);
}

double_helix& double_helix::
operator= (const double_helix& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
    this->pitch_ = x.pitch_;
    this->height_ = x.height_;
  }

  return *this;
}

double_helix::
~double_helix ()
{
}

// double_array
//

double_array::
double_array ()
: ::xml_schema::type (),
  value_ (this)
{
}

double_array::
double_array (const double_array& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

double_array::
double_array (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void double_array::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.push_back (value_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

double_array* double_array::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class double_array (*this, f, c);
}

double_array& double_array::
operator= (const double_array& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->value_ = x.value_;
  }

  return *this;
}

double_array::
~double_array ()
{
}

// positive_int
//

positive_int::
positive_int (const ::xml_schema::int_& _xsd_int__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (_xsd_int__base)
{
}

positive_int::
positive_int (const positive_int& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (x, f, c)
{
}

positive_int::
positive_int (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (e, f, c)
{
}

positive_int::
positive_int (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (a, f, c)
{
}

positive_int::
positive_int (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

positive_int* positive_int::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positive_int (*this, f, c);
}

positive_int::
~positive_int ()
{
}

// positive_double
//

positive_double::
positive_double (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

positive_double::
positive_double (const positive_double& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

positive_double::
positive_double (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

positive_double::
positive_double (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

positive_double::
positive_double (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

positive_double* positive_double::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positive_double (*this, f, c);
}

positive_double::
~positive_double ()
{
}

// Data
//

Data::
Data (const header_type& header)
: ::xml_schema::type (),
  header_ (header, this),
  linked_cells_ (this),
  vector_ (this),
  gravity_ (this),
  lennard_jones_ (this)
{
}

Data::
Data (::std::unique_ptr< header_type > header)
: ::xml_schema::type (),
  header_ (std::move (header), this),
  linked_cells_ (this),
  vector_ (this),
  gravity_ (this),
  lennard_jones_ (this)
{
}

Data::
Data (const Data& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  header_ (x.header_, f, this),
  linked_cells_ (x.linked_cells_, f, this),
  vector_ (x.vector_, f, this),
  gravity_ (x.gravity_, f, this),
  lennard_jones_ (x.lennard_jones_, f, this)
{
}

Data::
Data (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  header_ (this),
  linked_cells_ (this),
  vector_ (this),
  gravity_ (this),
  lennard_jones_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Data::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< header_type > r (
        header_traits::create (i, f, this));

      if (!header_.present ())
      {
        this->header_.set (::std::move (r));
        continue;
      }
    }

    // linked_cells
    //
    if (n.name () == "linked_cells" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< linked_cells_type > r (
        linked_cells_traits::create (i, f, this));

      if (!this->linked_cells_)
      {
        this->linked_cells_.set (::std::move (r));
        continue;
      }
    }

    // vector
    //
    if (n.name () == "vector" && n.namespace_ ().empty ())
    {
      if (!this->vector_)
      {
        this->vector_.set (vector_traits::create (i, f, this));
        continue;
      }
    }

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravity_type > r (
        gravity_traits::create (i, f, this));

      if (!this->gravity_)
      {
        this->gravity_.set (::std::move (r));
        continue;
      }
    }

    // lennard_jones
    //
    if (n.name () == "lennard_jones" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lennard_jones_type > r (
        lennard_jones_traits::create (i, f, this));

      if (!this->lennard_jones_)
      {
        this->lennard_jones_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!header_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "header",
      "");
  }
}

Data* Data::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Data (*this, f, c);
}

Data& Data::
operator= (const Data& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->header_ = x.header_;
    this->linked_cells_ = x.linked_cells_;
    this->vector_ = x.vector_;
    this->gravity_ = x.gravity_;
    this->lennard_jones_ = x.lennard_jones_;
  }

  return *this;
}

Data::
~Data ()
{
}

// header
//

header::
header (const base_name_type& base_name,
        const t_end_type& t_end,
        const output_frequency_type& output_frequency,
        const output_file_name_type& output_file_name,
        const seed_type& seed)
: ::xml_schema::type (),
  base_name_ (base_name, this),
  t_end_ (t_end, this),
  output_frequency_ (output_frequency, this),
  output_file_name_ (output_file_name, this),
  seed_ (seed, this)
{
}

header::
header (const header& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  base_name_ (x.base_name_, f, this),
  t_end_ (x.t_end_, f, this),
  output_frequency_ (x.output_frequency_, f, this),
  output_file_name_ (x.output_file_name_, f, this),
  seed_ (x.seed_, f, this)
{
}

header::
header (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  base_name_ (this),
  t_end_ (this),
  output_frequency_ (this),
  output_file_name_ (this),
  seed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "base_name" && n.namespace_ ().empty ())
    {
      this->base_name_.set (base_name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      this->t_end_.set (t_end_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_frequency" && n.namespace_ ().empty ())
    {
      this->output_frequency_.set (output_frequency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_file_name" && n.namespace_ ().empty ())
    {
      this->output_file_name_.set (output_file_name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "seed" && n.namespace_ ().empty ())
    {
      this->seed_.set (seed_traits::create (i, f, this));
      continue;
    }
  }

  if (!base_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "base_name",
      "");
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t_end",
      "");
  }

  if (!output_frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_frequency",
      "");
  }

  if (!output_file_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_file_name",
      "");
  }

  if (!seed_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "seed",
      "");
  }
}

header* header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class header (*this, f, c);
}

header& header::
operator= (const header& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->base_name_ = x.base_name_;
    this->t_end_ = x.t_end_;
    this->output_frequency_ = x.output_frequency_;
    this->output_file_name_ = x.output_file_name_;
    this->seed_ = x.seed_;
  }

  return *this;
}

header::
~header ()
{
}

// linked_cells
//

linked_cells::
linked_cells (const domain_size_type& domain_size,
              const boundary_conditions_type& boundary_conditions)
: ::xml_schema::type (),
  domain_size_ (domain_size, this),
  boundary_conditions_ (boundary_conditions, this)
{
}

linked_cells::
linked_cells (::std::unique_ptr< domain_size_type > domain_size,
              ::std::unique_ptr< boundary_conditions_type > boundary_conditions)
: ::xml_schema::type (),
  domain_size_ (std::move (domain_size), this),
  boundary_conditions_ (std::move (boundary_conditions), this)
{
}

linked_cells::
linked_cells (::std::unique_ptr< domain_size_type > domain_size)
: ::xml_schema::type (),
  domain_size_ (std::move (domain_size), this)
{
}

linked_cells::
linked_cells (const linked_cells& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  domain_size_ (x.domain_size_, f, this),
  boundary_conditions_ (x.boundary_conditions_, f, this)
{
}

linked_cells::
linked_cells (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  domain_size_ (this),
  boundary_conditions_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void linked_cells::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (::std::move (r));
        continue;
      }
    }

    // boundary_conditions
    //
    if (n.name () == "boundary_conditions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_conditions_type > r (
        boundary_conditions_traits::create (i, f, this));

      if (!boundary_conditions_.present ())
      {
        this->boundary_conditions_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain_size",
      "");
  }

  if (!boundary_conditions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary_conditions",
      "");
  }
}

linked_cells* linked_cells::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class linked_cells (*this, f, c);
}

linked_cells& linked_cells::
operator= (const linked_cells& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->domain_size_ = x.domain_size_;
    this->boundary_conditions_ = x.boundary_conditions_;
  }

  return *this;
}

linked_cells::
~linked_cells ()
{
}

// gravity
//

gravity::
gravity (const total_bodies_type& total_bodies,
         const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  total_bodies_ (total_bodies, this),
  cutoff_radius_ (cutoff_radius, this),
  celestial_body_ (this)
{
}

gravity::
gravity (const gravity& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  total_bodies_ (x.total_bodies_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this),
  celestial_body_ (x.celestial_body_, f, this)
{
}

gravity::
gravity (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  total_bodies_ (this),
  cutoff_radius_ (this),
  celestial_body_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void gravity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // total_bodies
    //
    if (n.name () == "total_bodies" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< total_bodies_type > r (
        total_bodies_traits::create (i, f, this));

      if (!total_bodies_.present ())
      {
        this->total_bodies_.set (::std::move (r));
        continue;
      }
    }

    // cutoff_radius
    //
    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cutoff_radius_type > r (
        cutoff_radius_traits::create (i, f, this));

      if (!cutoff_radius_.present ())
      {
        this->cutoff_radius_.set (::std::move (r));
        continue;
      }
    }

    // celestial_body
    //
    if (n.name () == "celestial_body" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< celestial_body_type > r (
        celestial_body_traits::create (i, f, this));

      this->celestial_body_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!total_bodies_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "total_bodies",
      "");
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoff_radius",
      "");
  }
}

gravity* gravity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravity (*this, f, c);
}

gravity& gravity::
operator= (const gravity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->total_bodies_ = x.total_bodies_;
    this->cutoff_radius_ = x.cutoff_radius_;
    this->celestial_body_ = x.celestial_body_;
  }

  return *this;
}

gravity::
~gravity ()
{
}

// lennard_jones
//

lennard_jones::
lennard_jones (const settings_type& settings)
: ::xml_schema::type (),
  settings_ (settings, this),
  cuboids_ (this),
  discs_ (this),
  spheres_ (this),
  tori_ (this),
  double_helices_ (this)
{
}

lennard_jones::
lennard_jones (::std::unique_ptr< settings_type > settings)
: ::xml_schema::type (),
  settings_ (std::move (settings), this),
  cuboids_ (this),
  discs_ (this),
  spheres_ (this),
  tori_ (this),
  double_helices_ (this)
{
}

lennard_jones::
lennard_jones (const lennard_jones& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  settings_ (x.settings_, f, this),
  cuboids_ (x.cuboids_, f, this),
  discs_ (x.discs_, f, this),
  spheres_ (x.spheres_, f, this),
  tori_ (x.tori_, f, this),
  double_helices_ (x.double_helices_, f, this)
{
}

lennard_jones::
lennard_jones (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  settings_ (this),
  cuboids_ (this),
  discs_ (this),
  spheres_ (this),
  tori_ (this),
  double_helices_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lennard_jones::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // settings
    //
    if (n.name () == "settings" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< settings_type > r (
        settings_traits::create (i, f, this));

      if (!settings_.present ())
      {
        this->settings_.set (::std::move (r));
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      if (!this->cuboids_)
      {
        this->cuboids_.set (::std::move (r));
        continue;
      }
    }

    // discs
    //
    if (n.name () == "discs" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< discs_type > r (
        discs_traits::create (i, f, this));

      if (!this->discs_)
      {
        this->discs_.set (::std::move (r));
        continue;
      }
    }

    // spheres
    //
    if (n.name () == "spheres" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< spheres_type > r (
        spheres_traits::create (i, f, this));

      if (!this->spheres_)
      {
        this->spheres_.set (::std::move (r));
        continue;
      }
    }

    // tori
    //
    if (n.name () == "tori" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< tori_type > r (
        tori_traits::create (i, f, this));

      if (!this->tori_)
      {
        this->tori_.set (::std::move (r));
        continue;
      }
    }

    // double_helices
    //
    if (n.name () == "double_helices" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< double_helices_type > r (
        double_helices_traits::create (i, f, this));

      if (!this->double_helices_)
      {
        this->double_helices_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!settings_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "settings",
      "");
  }
}

lennard_jones* lennard_jones::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lennard_jones (*this, f, c);
}

lennard_jones& lennard_jones::
operator= (const lennard_jones& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->settings_ = x.settings_;
    this->cuboids_ = x.cuboids_;
    this->discs_ = x.discs_;
    this->spheres_ = x.spheres_;
    this->tori_ = x.tori_;
    this->double_helices_ = x.double_helices_;
  }

  return *this;
}

lennard_jones::
~lennard_jones ()
{
}

// boundary_conditions
//

boundary_conditions::
boundary_conditions ()
: ::xml_schema::type (),
  boundary_condition_ (this)
{
}

boundary_conditions::
boundary_conditions (const boundary_conditions& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  boundary_condition_ (x.boundary_condition_, f, this)
{
}

boundary_conditions::
boundary_conditions (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  boundary_condition_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundary_conditions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // boundary_condition
    //
    if (n.name () == "boundary_condition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_condition_type > r (
        boundary_condition_traits::create (i, f, this));

      this->boundary_condition_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

boundary_conditions* boundary_conditions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_conditions (*this, f, c);
}

boundary_conditions& boundary_conditions::
operator= (const boundary_conditions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->boundary_condition_ = x.boundary_condition_;
  }

  return *this;
}

boundary_conditions::
~boundary_conditions ()
{
}

// settings
//

settings::
settings (const delta_t_type& delta_t,
          const sigma_type& sigma,
          const epsilon_type& epsilon,
          const mass_m_type& mass_m,
          const distance_h_type& distance_h,
          const brown_motion_type& brown_motion,
          const cutoff_radius_type& cutoff_radius)
: ::xml_schema::type (),
  delta_t_ (delta_t, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this),
  mass_m_ (mass_m, this),
  distance_h_ (distance_h, this),
  brown_motion_ (brown_motion, this),
  cutoff_radius_ (cutoff_radius, this)
{
}

settings::
settings (const settings& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  delta_t_ (x.delta_t_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this),
  mass_m_ (x.mass_m_, f, this),
  distance_h_ (x.distance_h_, f, this),
  brown_motion_ (x.brown_motion_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this)
{
}

settings::
settings (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  delta_t_ (this),
  sigma_ (this),
  epsilon_ (this),
  mass_m_ (this),
  distance_h_ (this),
  brown_motion_ (this),
  cutoff_radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void settings::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      this->delta_t_.set (delta_t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (sigma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (epsilon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass_m" && n.namespace_ ().empty ())
    {
      this->mass_m_.set (mass_m_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "distance_h" && n.namespace_ ().empty ())
    {
      this->distance_h_.set (distance_h_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "brown_motion" && n.namespace_ ().empty ())
    {
      this->brown_motion_.set (brown_motion_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      this->cutoff_radius_.set (cutoff_radius_traits::create (i, f, this));
      continue;
    }
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "delta_t",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "epsilon",
      "");
  }

  if (!mass_m_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mass_m",
      "");
  }

  if (!distance_h_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "distance_h",
      "");
  }

  if (!brown_motion_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "brown_motion",
      "");
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "cutoff_radius",
      "");
  }
}

settings* settings::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class settings (*this, f, c);
}

settings& settings::
operator= (const settings& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->delta_t_ = x.delta_t_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
    this->mass_m_ = x.mass_m_;
    this->distance_h_ = x.distance_h_;
    this->brown_motion_ = x.brown_motion_;
    this->cutoff_radius_ = x.cutoff_radius_;
  }

  return *this;
}

settings::
~settings ()
{
}

// cuboids
//

cuboids::
cuboids ()
: ::xml_schema::type (),
  Cuboid_ (this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Cuboid_ (x.Cuboid_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Cuboid
    //
    if (n.name () == "Cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Cuboid_type > r (
        Cuboid_traits::create (i, f, this));

      this->Cuboid_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Cuboid_ = x.Cuboid_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// discs
//

discs::
discs ()
: ::xml_schema::type (),
  Disc_ (this)
{
}

discs::
discs (const discs& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Disc_ (x.Disc_, f, this)
{
}

discs::
discs (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Disc_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void discs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Disc
    //
    if (n.name () == "Disc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Disc_type > r (
        Disc_traits::create (i, f, this));

      this->Disc_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

discs* discs::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class discs (*this, f, c);
}

discs& discs::
operator= (const discs& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Disc_ = x.Disc_;
  }

  return *this;
}

discs::
~discs ()
{
}

// spheres
//

spheres::
spheres ()
: ::xml_schema::type (),
  Sphere_ (this)
{
}

spheres::
spheres (const spheres& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Sphere_ (x.Sphere_, f, this)
{
}

spheres::
spheres (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Sphere_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void spheres::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Sphere
    //
    if (n.name () == "Sphere" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Sphere_type > r (
        Sphere_traits::create (i, f, this));

      this->Sphere_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

spheres* spheres::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spheres (*this, f, c);
}

spheres& spheres::
operator= (const spheres& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Sphere_ = x.Sphere_;
  }

  return *this;
}

spheres::
~spheres ()
{
}

// tori
//

tori::
tori ()
: ::xml_schema::type (),
  Torus_ (this)
{
}

tori::
tori (const tori& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Torus_ (x.Torus_, f, this)
{
}

tori::
tori (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Torus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void tori::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Torus
    //
    if (n.name () == "Torus" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Torus_type > r (
        Torus_traits::create (i, f, this));

      this->Torus_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

tori* tori::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tori (*this, f, c);
}

tori& tori::
operator= (const tori& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Torus_ = x.Torus_;
  }

  return *this;
}

tori::
~tori ()
{
}

// double_helices
//

double_helices::
double_helices ()
: ::xml_schema::type (),
  double_helix_ (this)
{
}

double_helices::
double_helices (const double_helices& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  double_helix_ (x.double_helix_, f, this)
{
}

double_helices::
double_helices (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  double_helix_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void double_helices::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // double_helix
    //
    if (n.name () == "double_helix" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< double_helix_type > r (
        double_helix_traits::create (i, f, this));

      this->double_helix_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

double_helices* double_helices::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class double_helices (*this, f, c);
}

double_helices& double_helices::
operator= (const double_helices& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->double_helix_ = x.double_helix_;
  }

  return *this;
}

double_helices::
~double_helices ()
{
}

// boundary_condition
//

boundary_condition::
boundary_condition (const type_type& type)
: ::xml_schema::type (),
  type_ (type, this)
{
}

boundary_condition::
boundary_condition (const boundary_condition& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this)
{
}

boundary_condition::
boundary_condition (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void boundary_condition::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      this->type_.set (type_traits::create (i, f, this));
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

boundary_condition* boundary_condition::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_condition (*this, f, c);
}

boundary_condition& boundary_condition::
operator= (const boundary_condition& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
  }

  return *this;
}

boundary_condition::
~boundary_condition ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::Data >
Data_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Data_ (isrc, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Data_ (isrc, h, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Data_ (isrc, h, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Data_ (isrc, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Data_ (isrc, h, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Data_ (isrc, h, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Data > (
      ::Data_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Data" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Data > r (
      ::xsd::cxx::tree::traits< ::Data, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Data",
    "");
}

::std::unique_ptr< ::Data >
Data_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Data" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Data > r (
      ::xsd::cxx::tree::traits< ::Data, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Data",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
Data_ (::std::ostream& o,
       const ::Data& s,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Data_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Data_ (::std::ostream& o,
       const ::Data& s,
       ::xml_schema::error_handler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Data_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Data_ (::std::ostream& o,
       const ::Data& s,
       ::xercesc::DOMErrorHandler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Data_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Data_ (::xercesc::XMLFormatTarget& t,
       const ::Data& s,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Data_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Data_ (::xercesc::XMLFormatTarget& t,
       const ::Data& s,
       ::xml_schema::error_handler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Data_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Data_ (::xercesc::XMLFormatTarget& t,
       const ::Data& s,
       ::xercesc::DOMErrorHandler& h,
       const ::xml_schema::namespace_infomap& m,
       const ::std::string& e,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Data_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Data_ (::xercesc::DOMDocument& d,
       const ::Data& s,
       ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Data" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Data",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
Data_ (const ::Data& s,
       const ::xml_schema::namespace_infomap& m,
       ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "Data",
      "",
      m, f));

  ::Data_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const celestial_body& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // mass
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mass",
        e));

    s << i.mass ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const cuboid& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // particle_counts
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "particle_counts",
        e));

    s << i.particle_counts ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const disc& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << i.radius ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const sphere& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << i.radius ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const torus& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // major_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "major_radius",
        e));

    s << i.major_radius ();
  }

  // minor_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "minor_radius",
        e));

    s << i.minor_radius ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const double_helix& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinate",
        e));

    s << i.coordinate ();
  }

  // velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "velocity",
        e));

    s << i.velocity ();
  }

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << i.radius ();
  }

  // pitch
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "pitch",
        e));

    s << i.pitch ();
  }

  // height
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "height",
        e));

    s << i.height ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const double_array& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // value
  //
  for (double_array::value_const_iterator
       b (i.value ().begin ()), n (i.value ().end ());
       b != n; ++b)
  {
    const double_array::value_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "value",
        e));

    s << ::xml_schema::as_double (x);
  }
}

void
operator<< (::xercesc::DOMElement& e, const positive_int& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const positive_int& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const positive_int& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const positive_double& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const positive_double& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const positive_double& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const Data& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // header
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "header",
        e));

    s << i.header ();
  }

  // linked_cells
  //
  if (i.linked_cells ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "linked_cells",
        e));

    s << *i.linked_cells ();
  }

  // vector
  //
  if (i.vector ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "vector",
        e));

    s << *i.vector ();
  }

  // gravity
  //
  if (i.gravity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "gravity",
        e));

    s << *i.gravity ();
  }

  // lennard_jones
  //
  if (i.lennard_jones ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "lennard_jones",
        e));

    s << *i.lennard_jones ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const header& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // base_name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "base_name",
        e));

    a << i.base_name ();
  }

  // t_end
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "t_end",
        e));

    a << i.t_end ();
  }

  // output_frequency
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "output_frequency",
        e));

    a << i.output_frequency ();
  }

  // output_file_name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "output_file_name",
        e));

    a << i.output_file_name ();
  }

  // seed
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "seed",
        e));

    a << i.seed ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const linked_cells& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // domain_size
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "domain_size",
        e));

    s << i.domain_size ();
  }

  // boundary_conditions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "boundary_conditions",
        e));

    s << i.boundary_conditions ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const gravity& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // total_bodies
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "total_bodies",
        e));

    s << i.total_bodies ();
  }

  // cutoff_radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cutoff_radius",
        e));

    s << i.cutoff_radius ();
  }

  // celestial_body
  //
  for (gravity::celestial_body_const_iterator
       b (i.celestial_body ().begin ()), n (i.celestial_body ().end ());
       b != n; ++b)
  {
    const gravity::celestial_body_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "celestial_body",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const lennard_jones& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // settings
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "settings",
        e));

    s << i.settings ();
  }

  // cuboids
  //
  if (i.cuboids ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cuboids",
        e));

    s << *i.cuboids ();
  }

  // discs
  //
  if (i.discs ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "discs",
        e));

    s << *i.discs ();
  }

  // spheres
  //
  if (i.spheres ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "spheres",
        e));

    s << *i.spheres ();
  }

  // tori
  //
  if (i.tori ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tori",
        e));

    s << *i.tori ();
  }

  // double_helices
  //
  if (i.double_helices ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "double_helices",
        e));

    s << *i.double_helices ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const boundary_conditions& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // boundary_condition
  //
  for (boundary_conditions::boundary_condition_const_iterator
       b (i.boundary_condition ().begin ()), n (i.boundary_condition ().end ());
       b != n; ++b)
  {
    const boundary_conditions::boundary_condition_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "boundary_condition",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const settings& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // delta_t
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "delta_t",
        e));

    a << ::xml_schema::as_double(i.delta_t ());
  }

  // sigma
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "sigma",
        e));

    a << ::xml_schema::as_double(i.sigma ());
  }

  // epsilon
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "epsilon",
        e));

    a << ::xml_schema::as_double(i.epsilon ());
  }

  // mass_m
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "mass_m",
        e));

    a << ::xml_schema::as_double(i.mass_m ());
  }

  // distance_h
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "distance_h",
        e));

    a << ::xml_schema::as_double(i.distance_h ());
  }

  // brown_motion
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "brown_motion",
        e));

    a << ::xml_schema::as_double(i.brown_motion ());
  }

  // cutoff_radius
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "cutoff_radius",
        e));

    a << i.cutoff_radius ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const cuboids& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Cuboid
  //
  for (cuboids::Cuboid_const_iterator
       b (i.Cuboid ().begin ()), n (i.Cuboid ().end ());
       b != n; ++b)
  {
    const cuboids::Cuboid_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cuboid",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const discs& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Disc
  //
  for (discs::Disc_const_iterator
       b (i.Disc ().begin ()), n (i.Disc ().end ());
       b != n; ++b)
  {
    const discs::Disc_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Disc",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const spheres& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Sphere
  //
  for (spheres::Sphere_const_iterator
       b (i.Sphere ().begin ()), n (i.Sphere ().end ());
       b != n; ++b)
  {
    const spheres::Sphere_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sphere",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const tori& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Torus
  //
  for (tori::Torus_const_iterator
       b (i.Torus ().begin ()), n (i.Torus ().end ());
       b != n; ++b)
  {
    const tori::Torus_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Torus",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const double_helices& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // double_helix
  //
  for (double_helices::double_helix_const_iterator
       b (i.double_helix ().begin ()), n (i.double_helix ().end ());
       b != n; ++b)
  {
    const double_helices::double_helix_type& x (*b);

    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "double_helix",
        e));

    s << x;
  }
}

void
operator<< (::xercesc::DOMElement& e, const boundary_condition& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

