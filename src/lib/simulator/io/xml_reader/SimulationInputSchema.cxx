// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SimulationInputSchema.hxx"

// double_array
//

const double_array::value_sequence& double_array::
value () const
{
  return this->value_;
}

double_array::value_sequence& double_array::
value ()
{
  return this->value_;
}

void double_array::
value (const value_sequence& s)
{
  this->value_ = s;
}


// celestial_body
//

const celestial_body::coordinate_type& celestial_body::
coordinate () const
{
  return this->coordinate_.get ();
}

celestial_body::coordinate_type& celestial_body::
coordinate ()
{
  return this->coordinate_.get ();
}

void celestial_body::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void celestial_body::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const celestial_body::velocity_type& celestial_body::
velocity () const
{
  return this->velocity_.get ();
}

celestial_body::velocity_type& celestial_body::
velocity ()
{
  return this->velocity_.get ();
}

void celestial_body::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void celestial_body::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const celestial_body::mass_type& celestial_body::
mass () const
{
  return this->mass_.get ();
}

celestial_body::mass_type& celestial_body::
mass ()
{
  return this->mass_.get ();
}

void celestial_body::
mass (const mass_type& x)
{
  this->mass_.set (x);
}


// cuboid
//

const cuboid::coordinate_type& cuboid::
coordinate () const
{
  return this->coordinate_.get ();
}

cuboid::coordinate_type& cuboid::
coordinate ()
{
  return this->coordinate_.get ();
}

void cuboid::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void cuboid::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const cuboid::particle_counts_type& cuboid::
particle_counts () const
{
  return this->particle_counts_.get ();
}

cuboid::particle_counts_type& cuboid::
particle_counts ()
{
  return this->particle_counts_.get ();
}

void cuboid::
particle_counts (const particle_counts_type& x)
{
  this->particle_counts_.set (x);
}

void cuboid::
particle_counts (::std::unique_ptr< particle_counts_type > x)
{
  this->particle_counts_.set (std::move (x));
}

const cuboid::velocity_type& cuboid::
velocity () const
{
  return this->velocity_.get ();
}

cuboid::velocity_type& cuboid::
velocity ()
{
  return this->velocity_.get ();
}

void cuboid::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboid::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}


// disc
//

const disc::coordinate_type& disc::
coordinate () const
{
  return this->coordinate_.get ();
}

disc::coordinate_type& disc::
coordinate ()
{
  return this->coordinate_.get ();
}

void disc::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void disc::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const disc::velocity_type& disc::
velocity () const
{
  return this->velocity_.get ();
}

disc::velocity_type& disc::
velocity ()
{
  return this->velocity_.get ();
}

void disc::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void disc::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const disc::radius_type& disc::
radius () const
{
  return this->radius_.get ();
}

disc::radius_type& disc::
radius ()
{
  return this->radius_.get ();
}

void disc::
radius (const radius_type& x)
{
  this->radius_.set (x);
}


// Data
//

const Data::header_type& Data::
header () const
{
  return this->header_.get ();
}

Data::header_type& Data::
header ()
{
  return this->header_.get ();
}

void Data::
header (const header_type& x)
{
  this->header_.set (x);
}

void Data::
header (::std::unique_ptr< header_type > x)
{
  this->header_.set (std::move (x));
}

const Data::gravity_optional& Data::
gravity () const
{
  return this->gravity_;
}

Data::gravity_optional& Data::
gravity ()
{
  return this->gravity_;
}

void Data::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void Data::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

void Data::
gravity (::std::unique_ptr< gravity_type > x)
{
  this->gravity_.set (std::move (x));
}

const Data::lennard_jones_optional& Data::
lennard_jones () const
{
  return this->lennard_jones_;
}

Data::lennard_jones_optional& Data::
lennard_jones ()
{
  return this->lennard_jones_;
}

void Data::
lennard_jones (const lennard_jones_type& x)
{
  this->lennard_jones_.set (x);
}

void Data::
lennard_jones (const lennard_jones_optional& x)
{
  this->lennard_jones_ = x;
}

void Data::
lennard_jones (::std::unique_ptr< lennard_jones_type > x)
{
  this->lennard_jones_.set (std::move (x));
}


// header
//

const header::base_name_type& header::
base_name () const
{
  return this->base_name_.get ();
}

header::base_name_type& header::
base_name ()
{
  return this->base_name_.get ();
}

void header::
base_name (const base_name_type& x)
{
  this->base_name_.set (x);
}

void header::
base_name (::std::unique_ptr< base_name_type > x)
{
  this->base_name_.set (std::move (x));
}

const header::t_end_type& header::
t_end () const
{
  return this->t_end_.get ();
}

header::t_end_type& header::
t_end ()
{
  return this->t_end_.get ();
}

void header::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

const header::output_frequency_type& header::
output_frequency () const
{
  return this->output_frequency_.get ();
}

header::output_frequency_type& header::
output_frequency ()
{
  return this->output_frequency_.get ();
}

void header::
output_frequency (const output_frequency_type& x)
{
  this->output_frequency_.set (x);
}

const header::output_file_name_type& header::
output_file_name () const
{
  return this->output_file_name_.get ();
}

header::output_file_name_type& header::
output_file_name ()
{
  return this->output_file_name_.get ();
}

void header::
output_file_name (const output_file_name_type& x)
{
  this->output_file_name_.set (x);
}

void header::
output_file_name (::std::unique_ptr< output_file_name_type > x)
{
  this->output_file_name_.set (std::move (x));
}

const header::seed_type& header::
seed () const
{
  return this->seed_.get ();
}

header::seed_type& header::
seed ()
{
  return this->seed_.get ();
}

void header::
seed (const seed_type& x)
{
  this->seed_.set (x);
}


// gravity
//

const gravity::total_bodies_type& gravity::
total_bodies () const
{
  return this->total_bodies_.get ();
}

gravity::total_bodies_type& gravity::
total_bodies ()
{
  return this->total_bodies_.get ();
}

void gravity::
total_bodies (const total_bodies_type& x)
{
  this->total_bodies_.set (x);
}

const gravity::celestial_body_sequence& gravity::
celestial_body () const
{
  return this->celestial_body_;
}

gravity::celestial_body_sequence& gravity::
celestial_body ()
{
  return this->celestial_body_;
}

void gravity::
celestial_body (const celestial_body_sequence& s)
{
  this->celestial_body_ = s;
}


// lennard_jones
//

const lennard_jones::settings_type& lennard_jones::
settings () const
{
  return this->settings_.get ();
}

lennard_jones::settings_type& lennard_jones::
settings ()
{
  return this->settings_.get ();
}

void lennard_jones::
settings (const settings_type& x)
{
  this->settings_.set (x);
}

void lennard_jones::
settings (::std::unique_ptr< settings_type > x)
{
  this->settings_.set (std::move (x));
}

const lennard_jones::cuboids_optional& lennard_jones::
cuboids () const
{
  return this->cuboids_;
}

lennard_jones::cuboids_optional& lennard_jones::
cuboids ()
{
  return this->cuboids_;
}

void lennard_jones::
cuboids (const cuboids_type& x)
{
  this->cuboids_.set (x);
}

void lennard_jones::
cuboids (const cuboids_optional& x)
{
  this->cuboids_ = x;
}

void lennard_jones::
cuboids (::std::unique_ptr< cuboids_type > x)
{
  this->cuboids_.set (std::move (x));
}

const lennard_jones::discs_optional& lennard_jones::
discs () const
{
  return this->discs_;
}

lennard_jones::discs_optional& lennard_jones::
discs ()
{
  return this->discs_;
}

void lennard_jones::
discs (const discs_type& x)
{
  this->discs_.set (x);
}

void lennard_jones::
discs (const discs_optional& x)
{
  this->discs_ = x;
}

void lennard_jones::
discs (::std::unique_ptr< discs_type > x)
{
  this->discs_.set (std::move (x));
}


// settings
//

const settings::delta_t_type& settings::
delta_t () const
{
  return this->delta_t_.get ();
}

settings::delta_t_type& settings::
delta_t ()
{
  return this->delta_t_.get ();
}

void settings::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const settings::sigma_type& settings::
sigma () const
{
  return this->sigma_.get ();
}

settings::sigma_type& settings::
sigma ()
{
  return this->sigma_.get ();
}

void settings::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const settings::epsilon_type& settings::
epsilon () const
{
  return this->epsilon_.get ();
}

settings::epsilon_type& settings::
epsilon ()
{
  return this->epsilon_.get ();
}

void settings::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const settings::mass_m_type& settings::
mass_m () const
{
  return this->mass_m_.get ();
}

settings::mass_m_type& settings::
mass_m ()
{
  return this->mass_m_.get ();
}

void settings::
mass_m (const mass_m_type& x)
{
  this->mass_m_.set (x);
}

const settings::distance_h_type& settings::
distance_h () const
{
  return this->distance_h_.get ();
}

settings::distance_h_type& settings::
distance_h ()
{
  return this->distance_h_.get ();
}

void settings::
distance_h (const distance_h_type& x)
{
  this->distance_h_.set (x);
}

const settings::brown_motion_type& settings::
brown_motion () const
{
  return this->brown_motion_.get ();
}

settings::brown_motion_type& settings::
brown_motion ()
{
  return this->brown_motion_.get ();
}

void settings::
brown_motion (const brown_motion_type& x)
{
  this->brown_motion_.set (x);
}


// cuboids
//

const cuboids::Cuboid_sequence& cuboids::
Cuboid () const
{
  return this->Cuboid_;
}

cuboids::Cuboid_sequence& cuboids::
Cuboid ()
{
  return this->Cuboid_;
}

void cuboids::
Cuboid (const Cuboid_sequence& s)
{
  this->Cuboid_ = s;
}


// discs
//

const discs::Disc_sequence& discs::
Disc () const
{
  return this->Disc_;
}

discs::Disc_sequence& discs::
Disc ()
{
  return this->Disc_;
}

void discs::
Disc (const Disc_sequence& s)
{
  this->Disc_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// double_array
//

double_array::
double_array ()
: ::xml_schema::type (),
  value_ (this)
{
}

double_array::
double_array (const double_array& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  value_ (x.value_, f, this)
{
}

double_array::
double_array (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  value_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void double_array::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // value
    //
    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      this->value_.push_back (value_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

double_array* double_array::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class double_array (*this, f, c);
}

double_array& double_array::
operator= (const double_array& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->value_ = x.value_;
  }

  return *this;
}

double_array::
~double_array ()
{
}

// celestial_body
//

celestial_body::
celestial_body (const coordinate_type& coordinate,
                const velocity_type& velocity,
                const mass_type& mass)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  mass_ (mass, this)
{
}

celestial_body::
celestial_body (::std::unique_ptr< coordinate_type > coordinate,
                ::std::unique_ptr< velocity_type > velocity,
                const mass_type& mass)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  mass_ (mass, this)
{
}

celestial_body::
celestial_body (const celestial_body& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this)
{
}

celestial_body::
celestial_body (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void celestial_body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

celestial_body* celestial_body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class celestial_body (*this, f, c);
}

celestial_body& celestial_body::
operator= (const celestial_body& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
  }

  return *this;
}

celestial_body::
~celestial_body ()
{
}

// cuboid
//

cuboid::
cuboid (const coordinate_type& coordinate,
        const particle_counts_type& particle_counts,
        const velocity_type& velocity)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  particle_counts_ (particle_counts, this),
  velocity_ (velocity, this)
{
}

cuboid::
cuboid (::std::unique_ptr< coordinate_type > coordinate,
        ::std::unique_ptr< particle_counts_type > particle_counts,
        ::std::unique_ptr< velocity_type > velocity)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  particle_counts_ (std::move (particle_counts), this),
  velocity_ (std::move (velocity), this)
{
}

cuboid::
cuboid (const cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  particle_counts_ (x.particle_counts_, f, this),
  velocity_ (x.velocity_, f, this)
{
}

cuboid::
cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  particle_counts_ (this),
  velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // particle_counts
    //
    if (n.name () == "particle_counts" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particle_counts_type > r (
        particle_counts_traits::create (i, f, this));

      if (!particle_counts_.present ())
      {
        this->particle_counts_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!particle_counts_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particle_counts",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }
}

cuboid* cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid (*this, f, c);
}

cuboid& cuboid::
operator= (const cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->particle_counts_ = x.particle_counts_;
    this->velocity_ = x.velocity_;
  }

  return *this;
}

cuboid::
~cuboid ()
{
}

// disc
//

disc::
disc (const coordinate_type& coordinate,
      const velocity_type& velocity,
      const radius_type& radius)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  velocity_ (velocity, this),
  radius_ (radius, this)
{
}

disc::
disc (::std::unique_ptr< coordinate_type > coordinate,
      ::std::unique_ptr< velocity_type > velocity,
      const radius_type& radius)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  velocity_ (std::move (velocity), this),
  radius_ (radius, this)
{
}

disc::
disc (const disc& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  velocity_ (x.velocity_, f, this),
  radius_ (x.radius_, f, this)
{
}

disc::
disc (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  velocity_ (this),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void disc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }
}

disc* disc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class disc (*this, f, c);
}

disc& disc::
operator= (const disc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->velocity_ = x.velocity_;
    this->radius_ = x.radius_;
  }

  return *this;
}

disc::
~disc ()
{
}

// Data
//

Data::
Data (const header_type& header)
: ::xml_schema::type (),
  header_ (header, this),
  gravity_ (this),
  lennard_jones_ (this)
{
}

Data::
Data (::std::unique_ptr< header_type > header)
: ::xml_schema::type (),
  header_ (std::move (header), this),
  gravity_ (this),
  lennard_jones_ (this)
{
}

Data::
Data (const Data& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  header_ (x.header_, f, this),
  gravity_ (x.gravity_, f, this),
  lennard_jones_ (x.lennard_jones_, f, this)
{
}

Data::
Data (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  header_ (this),
  gravity_ (this),
  lennard_jones_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void Data::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // header
    //
    if (n.name () == "header" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< header_type > r (
        header_traits::create (i, f, this));

      if (!header_.present ())
      {
        this->header_.set (::std::move (r));
        continue;
      }
    }

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravity_type > r (
        gravity_traits::create (i, f, this));

      if (!this->gravity_)
      {
        this->gravity_.set (::std::move (r));
        continue;
      }
    }

    // lennard_jones
    //
    if (n.name () == "lennard_jones" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lennard_jones_type > r (
        lennard_jones_traits::create (i, f, this));

      if (!this->lennard_jones_)
      {
        this->lennard_jones_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!header_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "header",
      "");
  }
}

Data* Data::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Data (*this, f, c);
}

Data& Data::
operator= (const Data& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->header_ = x.header_;
    this->gravity_ = x.gravity_;
    this->lennard_jones_ = x.lennard_jones_;
  }

  return *this;
}

Data::
~Data ()
{
}

// header
//

header::
header (const base_name_type& base_name,
        const t_end_type& t_end,
        const output_frequency_type& output_frequency,
        const output_file_name_type& output_file_name,
        const seed_type& seed)
: ::xml_schema::type (),
  base_name_ (base_name, this),
  t_end_ (t_end, this),
  output_frequency_ (output_frequency, this),
  output_file_name_ (output_file_name, this),
  seed_ (seed, this)
{
}

header::
header (const header& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  base_name_ (x.base_name_, f, this),
  t_end_ (x.t_end_, f, this),
  output_frequency_ (x.output_frequency_, f, this),
  output_file_name_ (x.output_file_name_, f, this),
  seed_ (x.seed_, f, this)
{
}

header::
header (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  base_name_ (this),
  t_end_ (this),
  output_frequency_ (this),
  output_file_name_ (this),
  seed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void header::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "base_name" && n.namespace_ ().empty ())
    {
      this->base_name_.set (base_name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      this->t_end_.set (t_end_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_frequency" && n.namespace_ ().empty ())
    {
      this->output_frequency_.set (output_frequency_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "output_file_name" && n.namespace_ ().empty ())
    {
      this->output_file_name_.set (output_file_name_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "seed" && n.namespace_ ().empty ())
    {
      this->seed_.set (seed_traits::create (i, f, this));
      continue;
    }
  }

  if (!base_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "base_name",
      "");
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "t_end",
      "");
  }

  if (!output_frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_frequency",
      "");
  }

  if (!output_file_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "output_file_name",
      "");
  }

  if (!seed_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "seed",
      "");
  }
}

header* header::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class header (*this, f, c);
}

header& header::
operator= (const header& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->base_name_ = x.base_name_;
    this->t_end_ = x.t_end_;
    this->output_frequency_ = x.output_frequency_;
    this->output_file_name_ = x.output_file_name_;
    this->seed_ = x.seed_;
  }

  return *this;
}

header::
~header ()
{
}

// gravity
//

gravity::
gravity (const total_bodies_type& total_bodies)
: ::xml_schema::type (),
  total_bodies_ (total_bodies, this),
  celestial_body_ (this)
{
}

gravity::
gravity (const gravity& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  total_bodies_ (x.total_bodies_, f, this),
  celestial_body_ (x.celestial_body_, f, this)
{
}

gravity::
gravity (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  total_bodies_ (this),
  celestial_body_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void gravity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // total_bodies
    //
    if (n.name () == "total_bodies" && n.namespace_ ().empty ())
    {
      if (!total_bodies_.present ())
      {
        this->total_bodies_.set (total_bodies_traits::create (i, f, this));
        continue;
      }
    }

    // celestial_body
    //
    if (n.name () == "celestial_body" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< celestial_body_type > r (
        celestial_body_traits::create (i, f, this));

      this->celestial_body_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  if (!total_bodies_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "total_bodies",
      "");
  }
}

gravity* gravity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravity (*this, f, c);
}

gravity& gravity::
operator= (const gravity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->total_bodies_ = x.total_bodies_;
    this->celestial_body_ = x.celestial_body_;
  }

  return *this;
}

gravity::
~gravity ()
{
}

// lennard_jones
//

lennard_jones::
lennard_jones (const settings_type& settings)
: ::xml_schema::type (),
  settings_ (settings, this),
  cuboids_ (this),
  discs_ (this)
{
}

lennard_jones::
lennard_jones (::std::unique_ptr< settings_type > settings)
: ::xml_schema::type (),
  settings_ (std::move (settings), this),
  cuboids_ (this),
  discs_ (this)
{
}

lennard_jones::
lennard_jones (const lennard_jones& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  settings_ (x.settings_, f, this),
  cuboids_ (x.cuboids_, f, this),
  discs_ (x.discs_, f, this)
{
}

lennard_jones::
lennard_jones (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  settings_ (this),
  cuboids_ (this),
  discs_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lennard_jones::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // settings
    //
    if (n.name () == "settings" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< settings_type > r (
        settings_traits::create (i, f, this));

      if (!settings_.present ())
      {
        this->settings_.set (::std::move (r));
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      if (!this->cuboids_)
      {
        this->cuboids_.set (::std::move (r));
        continue;
      }
    }

    // discs
    //
    if (n.name () == "discs" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< discs_type > r (
        discs_traits::create (i, f, this));

      if (!this->discs_)
      {
        this->discs_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!settings_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "settings",
      "");
  }
}

lennard_jones* lennard_jones::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lennard_jones (*this, f, c);
}

lennard_jones& lennard_jones::
operator= (const lennard_jones& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->settings_ = x.settings_;
    this->cuboids_ = x.cuboids_;
    this->discs_ = x.discs_;
  }

  return *this;
}

lennard_jones::
~lennard_jones ()
{
}

// settings
//

settings::
settings (const delta_t_type& delta_t,
          const sigma_type& sigma,
          const epsilon_type& epsilon,
          const mass_m_type& mass_m,
          const distance_h_type& distance_h,
          const brown_motion_type& brown_motion)
: ::xml_schema::type (),
  delta_t_ (delta_t, this),
  sigma_ (sigma, this),
  epsilon_ (epsilon, this),
  mass_m_ (mass_m, this),
  distance_h_ (distance_h, this),
  brown_motion_ (brown_motion, this)
{
}

settings::
settings (const settings& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  delta_t_ (x.delta_t_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this),
  mass_m_ (x.mass_m_, f, this),
  distance_h_ (x.distance_h_, f, this),
  brown_motion_ (x.brown_motion_, f, this)
{
}

settings::
settings (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  delta_t_ (this),
  sigma_ (this),
  epsilon_ (this),
  mass_m_ (this),
  distance_h_ (this),
  brown_motion_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void settings::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      this->delta_t_.set (delta_t_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (sigma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (epsilon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass_m" && n.namespace_ ().empty ())
    {
      this->mass_m_.set (mass_m_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "distance_h" && n.namespace_ ().empty ())
    {
      this->distance_h_.set (distance_h_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "brown_motion" && n.namespace_ ().empty ())
    {
      this->brown_motion_.set (brown_motion_traits::create (i, f, this));
      continue;
    }
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "delta_t",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "sigma",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "epsilon",
      "");
  }

  if (!mass_m_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mass_m",
      "");
  }

  if (!distance_h_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "distance_h",
      "");
  }

  if (!brown_motion_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "brown_motion",
      "");
  }
}

settings* settings::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class settings (*this, f, c);
}

settings& settings::
operator= (const settings& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->delta_t_ = x.delta_t_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
    this->mass_m_ = x.mass_m_;
    this->distance_h_ = x.distance_h_;
    this->brown_motion_ = x.brown_motion_;
  }

  return *this;
}

settings::
~settings ()
{
}

// cuboids
//

cuboids::
cuboids ()
: ::xml_schema::type (),
  Cuboid_ (this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Cuboid_ (x.Cuboid_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Cuboid
    //
    if (n.name () == "Cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Cuboid_type > r (
        Cuboid_traits::create (i, f, this));

      this->Cuboid_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Cuboid_ = x.Cuboid_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// discs
//

discs::
discs ()
: ::xml_schema::type (),
  Disc_ (this)
{
}

discs::
discs (const discs& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Disc_ (x.Disc_, f, this)
{
}

discs::
discs (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Disc_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void discs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Disc
    //
    if (n.name () == "Disc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Disc_type > r (
        Disc_traits::create (i, f, this));

      this->Disc_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

discs* discs::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class discs (*this, f, c);
}

discs& discs::
operator= (const discs& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Disc_ = x.Disc_;
  }

  return *this;
}

discs::
~discs ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::Data >
Data_ (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Data_ (isrc, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Data_ (isrc, h, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Data_ (isrc, h, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Data_ (isrc, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Data_ (isrc, h, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Data_ (isrc, h, f, p);
}

::std::unique_ptr< ::Data >
Data_ (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::Data > (
    ::Data_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::Data >
Data_ (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::Data > (
      ::Data_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Data" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Data > r (
      ::xsd::cxx::tree::traits< ::Data, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Data",
    "");
}

::std::unique_ptr< ::Data >
Data_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Data" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::Data > r (
      ::xsd::cxx::tree::traits< ::Data, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Data",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

